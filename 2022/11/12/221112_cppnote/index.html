<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="John Doe">







<title>CppNote | rainman 小站</title>



    <link rel="icon" href="/favicon.jpg">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/menu.js"></script>
    




    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>







  <meta name="generator" content="Hexo 7.1.1"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            回到主页
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/friends/">友链</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">归档</a>
              </li> 
                   
          
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
                
                    <span class="post-tag">
                        <a href="/tags/C/">
                            C++
                        </a>
                    </span>    
                           
            
        </div>
        <div class="post-title">
            
            
                CppNote
            
            
        </div>
        <span class="post-date">
            Nov 12, 2022
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <p>本文是通过第五版《C++ primer》进行的查漏补缺。</p>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>标准库定义了4个IO对象：</p>
<ul>
<li>cin : istream类型的对象，标准输入（standard input）</li>
<li>cout : ostream类型的对象，标准输出（standard output）</li>
<li>cerr : ostream类型的对象，标准错误（standard error）</li>
<li>clog : ostream类型的对象，用来输出程序运行时的一般信息</li>
</ul>
<p>一种不用namespace std的写法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;enter two numbers:&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="type">int</span> v1=<span class="number">0</span>, v2=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    std::cin&gt;&gt;v1&gt;&gt;v2;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;the sum of &quot;</span>&lt;&lt;v1&lt;&lt;<span class="string">&quot; and &quot;</span>&lt;&lt;v2&lt;&lt;<span class="string">&quot; is &quot;</span>&lt;&lt;v1+v2&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::cout</code> 两个冒号是一个运算符，作用域运算符。它表示我要把<code>std</code>作用域里面的<code>cout</code>拿出来用。</p>
<p><code>endl</code> 操作符，结束当前行，将设备相关的缓冲区内容刷到屏幕上。</p>
<p><code>cin</code>可以跳过空格、制表符、换行符等空白字符。</p>
<p>一般来说，自己创建的头文件，用双引号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>, value=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(std::cin&gt;&gt;value)&#123; <span class="comment">//读取数值直到文件结尾，或读入错误</span></span><br><span class="line">        sum+=value;       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;the sum is &quot;</span>&lt;&lt;sum&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上例中，无效的istream对象会使条件变为假，例如输入一个字母（非int型）。</p>
<h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><p><code>char</code>比较特殊，分为三种：<code>char</code>、<code>signed char</code>、<code>unsigned char</code>，<code>char</code>是<code>signed char</code>或<code>unsigned char</code>其中的一种，由编译器决定：VC编译器、x86上的GCC都把char定义为<code>signed char</code>，而arm-linux-gcc把char定义为<code>unsigned char</code>。</p>
<p>为了保持程序的移植性，应当明确指出到底是哪一种。</p>
<p>三者都占1个字节。<code>signed char</code>取值范围是<code>-128~127</code>(有符号位)，<code>unsigned char</code>取值范围是<code>0~255</code>。</p>
<p>原始的ASCII标准里，定义的字符码值是只有<code>0~127</code>，所以怎么定义的char都刚好装得下。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>记一种写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">book</span><span class="params">(<span class="string">&quot;newbrush&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//what...?</span></span><br><span class="line">    std::cout&lt;&lt;book&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果（输出了字符串）：</span></span><br><span class="line"><span class="comment">//newbrush</span></span><br></pre></td></tr></table></figure>
<p>初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> units_sold = <span class="number">0</span>; <span class="comment">//以前的写法</span></span><br><span class="line"><span class="type">int</span> units_sold = &#123;<span class="number">0</span>&#125;; <span class="comment">//列表初始化（C++11）</span></span><br><span class="line"><span class="type">int</span> units_sold&#123;<span class="number">0</span>&#125;; <span class="comment">//列表初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若使用列表初始化，且初始值存在丢失信息的风险，则编译器报错：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> ld=<span class="number">3.1415926536</span>;</span><br><span class="line"><span class="type">int</span> a&#123;ld&#125;,b=&#123;ld&#125;; <span class="comment">//报错，转换未执行</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">c</span><span class="params">(ld)</span>,d</span>=ld; <span class="comment">//旧写法，不报错，转换执行，同时丢失了部分值</span></span><br></pre></td></tr></table></figure>
<p>若只声明而不定义，就在变量前添加<code>extern</code>关键字，且不要显式地初始化变量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">//声明 i 而非定义 i</span></span><br><span class="line"><span class="type">int</span> j; <span class="comment">//声明并定义 j</span></span><br></pre></td></tr></table></figure>
<p>若不希望别的文件通过<code>extern</code>引用，可以使用<code>static</code>，这样作用域就是本文件。</p>
<p><strong>总结：</strong><code>extern</code>不是定义，是引入（声明）在其他源文件中定义的非<code>static</code>全局变量。</p>
<p>名字的作用域（scope）：</p>
<ul>
<li>同一个名字出现在程序的不同位置，也可能指向不同的实体。</li>
<li>C++中大多数作用域都以花括号分隔。</li>
<li>名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端作为结束。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个不好的例子</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> reused = <span class="number">42</span>; <span class="comment">// 全局作用域</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> unik = <span class="number">0</span>; <span class="comment">//块作用域</span></span><br><span class="line">    std::cout&lt;&lt;reused&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;unik&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> reused = <span class="number">0</span>; <span class="comment">//同名的新建局部变量，覆盖了全局变量</span></span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;reused&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;unik&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;::reused&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;unik&lt;&lt;std::endl;</span><br><span class="line">    <span class="comment">//显式地访问全局变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------------运行结果-----------</span></span><br><span class="line"><span class="comment">42 0</span></span><br><span class="line"><span class="comment">0 0</span></span><br><span class="line"><span class="comment">42 0</span></span><br><span class="line"><span class="comment">-------------------------------*/</span></span><br></pre></td></tr></table></figure>
<h2 id="复合类型（compound-type）"><a href="#复合类型（compound-type）" class="headerlink" title="复合类型（compound type）"></a>复合类型（compound type）</h2><p>引用（reference），为对象起的别名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal = ival; <span class="comment">//refVal 指向ival (是ival的另一个名字)</span></span><br><span class="line"><span class="type">int</span> &amp;refVal2; <span class="comment">//报错，引用必须初始化</span></span><br></pre></td></tr></table></figure>
<p>定义引用时，把引用和它的初始值绑定在一起，而不是把初始值拷贝给引用。引用不是对象，所以不能定义引用的引用，不能定义指向引用的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reVal = <span class="number">2</span>; <span class="comment">//把2给refVal指向的对象，即赋给了ival</span></span><br><span class="line"><span class="type">int</span> li = refVal; <span class="comment">//等同于li=ival</span></span><br><span class="line"><span class="type">int</span> &amp;refVal3 = refVal; <span class="comment">//正确：refVal3绑定到了那个与refVal绑定的对象上，即绑定了ival</span></span><br></pre></td></tr></table></figure>
<p>可以使用取地址符<code>&amp;</code>获取指针所封装的地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival; <span class="comment">//p是指向ival的指针</span></span><br><span class="line"><span class="type">double</span> *dp = &amp;ival; <span class="comment">//错误！类型不匹配</span></span><br></pre></td></tr></table></figure>
<p>对于“指针的值+1”的解释：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;hello this is a test&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">233</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;a;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;adress: &quot;</span>&lt;&lt;p&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;neirong: &quot;</span>&lt;&lt;*p&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;adress+1: &quot;</span>&lt;&lt;p+<span class="number">1</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*---------------运行结果----------------</span></span><br><span class="line"><span class="comment">hello this is a test</span></span><br><span class="line"><span class="comment">adress: 0x61fe14</span></span><br><span class="line"><span class="comment">neirong: 233</span></span><br><span class="line"><span class="comment">adress+1: 0x61fe18</span></span><br><span class="line"><span class="comment">---------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------explanation-----------</span></span><br><span class="line"><span class="comment">p+1的效果反映在地址上（单词拼错小问题）</span></span><br><span class="line"><span class="comment">在博主本人的机器上，int型占4个字节</span></span><br><span class="line"><span class="comment">--------------------------------*/</span></span><br></pre></td></tr></table></figure>
<p>可以使用解引用符<code>*</code>利用指针访问对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival; <span class="comment">//p是指向ival的指针</span></span><br><span class="line">std::cout&lt;&lt;*p; <span class="comment">//输出42</span></span><br><span class="line">*p=<span class="number">0</span>;</span><br><span class="line">std::cout&lt;&lt;*p <span class="comment">//输出0</span></span><br></pre></td></tr></table></figure>
<p>空指针（null pointer），不指向任何对象。在使用一个指针前，可以先检查它是否为空。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="literal">nullptr</span>; <span class="comment">//C++11 ，推荐写法</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p3 = <span class="literal">NULL</span>; <span class="comment">//需要 #include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line">p1 = zero; <span class="comment">//错误！类型不匹配</span></span><br></pre></td></tr></table></figure>
<p>void *指针，纯粹的地址封装，与类型无关。可以用于存放任意对象的地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> obj = <span class="number">3.14</span>, *pd = &amp;obj;</span><br><span class="line"><span class="type">void</span> *pv = &amp;obj;</span><br><span class="line">pv = pd;</span><br></pre></td></tr></table></figure>
<p>指向指针的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> *pi = &amp;ival;</span><br><span class="line"><span class="type">int</span> **ppi = &amp;pi; <span class="comment">//ppi指向一个int型的指针</span></span><br></pre></td></tr></table></figure>
<p>指针的引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> *&amp;r = p; <span class="comment">//r是一个对指针p的引用</span></span><br><span class="line">r = &amp;i; <span class="comment">//r引用了一个指针，就是令p指向i</span></span><br><span class="line">*r = <span class="number">0</span>; <span class="comment">//解引用得到i，将i的值改为0</span></span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line">    <span class="type">int</span>*&amp; r = p;  <span class="comment">//r是一个对指针p的引用</span></span><br><span class="line">    r = &amp;i;</span><br><span class="line">    cout &lt;&lt; *r &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; *p ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-----输出------</span></span><br><span class="line"><span class="comment">1024  1024</span></span><br><span class="line"><span class="comment">---------------*/</span></span><br></pre></td></tr></table></figure>
<h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><p><code>const</code>对象必须初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="built_in">get_size</span>(); <span class="comment">//正确，运行时初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j = <span class="number">42</span>; <span class="comment">//正确，编译时初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> k; <span class="comment">//错误！未初始化</span></span><br></pre></td></tr></table></figure>
<p>默认状态下，<code>const</code>对象仅在文件内有效，若想在多个文件间共享<code>const</code>对象，必须在变量的定义之前添加关键字<code>extern</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file_1.cc定义并初始化了一个常量，该常量能被其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="built_in">fcn</span>();</span><br><span class="line"><span class="comment">//file_1.h头文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize;</span><br></pre></td></tr></table></figure>
<p><code>const</code>的引用，对常量的引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = ci; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = ci; <span class="comment">//错误！存在通过r2改变ci（const）的风险</span></span><br></pre></td></tr></table></figure>
<p>一个奇怪的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri = dval; <span class="comment">//允许</span></span><br><span class="line"><span class="type">int</span> &amp;ri = dval; <span class="comment">//错误！因为改变的是编译器生成的中间量</span></span><br></pre></td></tr></table></figure>
<p>指向常量的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> *ptr = &amp;pi; <span class="comment">//错误！存在通过ptr指针修改pi的风险</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr = &amp;pi;</span><br><span class="line">*cptr = <span class="number">42</span>; <span class="comment">//错误！</span></span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line">cptr = &amp;dval; <span class="comment">//正确，但不能通过cptr修改dval的值</span></span><br></pre></td></tr></table></figure>
<p>const指针（必须初始化）：不变的是指针本身的值，而不是它指向的那个值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> curErr = &amp;errNumb; <span class="comment">//常指针，顶层</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *<span class="type">const</span> pip = &amp;pi; <span class="comment">//指向常量的常量指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(*curErr)&#123;</span><br><span class="line">    <span class="built_in">errorHandler</span>();</span><br><span class="line">    *curErr = <span class="number">0</span>; <span class="comment">//正确，试图修改变量errNumb</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*pip = <span class="number">2.71</span>; <span class="comment">//错误！试图修改常量pi</span></span><br></pre></td></tr></table></figure>
<p>顶层<code>const</code>：表示变量本身是一个常量。底层<code>const</code>：表示指针所指向的对象是一个<code>const</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i; <span class="comment">//顶层</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>; <span class="comment">//顶层</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;ci; <span class="comment">//底层</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = p2; <span class="comment">//（左：底层），（右：顶层）</span></span><br><span class="line"></span><br><span class="line">p2 = p3; <span class="comment">//正确。从顶层的角度来说，p2是个变量，p3是个常量，</span></span><br><span class="line">         <span class="comment">//这个赋值没有问题。从底层的角度来说，都是一样的，</span></span><br><span class="line">         <span class="comment">//指向的内容都是不会去修改的</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = p3; <span class="comment">//错误！存在通过*p修改*p3（const）的风险</span></span><br><span class="line">             <span class="comment">//p3的底层是const int ，而这个是int</span></span><br><span class="line"></span><br><span class="line">p2 = &amp;i; <span class="comment">//正确。只是不能通过p2修改i而已</span></span><br></pre></td></tr></table></figure>
<p><code>constexpr</code>变量（C++11标准）：允许将变量声明为<code>constexpr</code>类型，以便由编译器来验证变量的值是否是一个常量表达式。</p>
<ul>
<li>一定是一个常量</li>
<li>必须用常量表达式初始化</li>
<li>自定义类型、IO库、string等类型不能被定义为<code>constexpr</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> mf = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> limit = mf + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> sz = <span class="built_in">size</span>(); <span class="comment">//只有当size是一个constexpr函数时才正确</span></span><br></pre></td></tr></table></figure>
<p>指针和<code>constexpr</code>：限定符仅对指针有效，对其所指的对象无关。（对顶层有效，底层无效）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *np = <span class="literal">nullptr</span>; <span class="comment">//常指针</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//i和j必须定义在函数之外</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> *p = &amp;i; <span class="comment">//p是常指针，指向常量</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *p1 = &amp;j; <span class="comment">//p1是常指针，指向变量j</span></span><br></pre></td></tr></table></figure>
<h2 id="typedef、auto、decltype"><a href="#typedef、auto、decltype" class="headerlink" title="typedef、auto、decltype"></a>typedef、auto、decltype</h2><p>类型别名，提高可读性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages;</span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">//base是double的同义词，p是double *的同义词</span></span><br><span class="line"><span class="keyword">using</span> SI = Sales_item; <span class="comment">//C++11，别名声明。左边是别名</span></span><br></pre></td></tr></table></figure>
<p>对于指针，类型别名的使用可能会产生意想不到的结果（平时不用就好了）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *pstring;</span><br><span class="line"><span class="type">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">//指向char的常量指针</span></span><br><span class="line"><span class="type">const</span> pstring *ps; <span class="comment">//ps是指针变量，它的对象是指向char的常量指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *cstr = <span class="number">0</span>; <span class="comment">// ! 是对 const pstring cstr = 0; 的错误理解</span></span><br></pre></td></tr></table></figure>
<p>auto类型说明符，C++11，让编译器通过初始值推断变量的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>; <span class="comment">//错误！auto已经被推断为int，后面却不一致</span></span><br></pre></td></tr></table></figure>
<p>看看就好，不要较真，我觉得一般不会用到这些：</p>
<p><img src="https://s2.loli.net/2022/11/14/UkY4gMpC5uBAzGT.png" alt="17-1.png"></p>
<p><code>decltype</code>类型说明符，获取表达式的类型。在编译时推导出一个表达式的类型，并且不会计算表达式的值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y = <span class="number">1</span>; 			<span class="comment">// y -&gt;  int</span></span><br><span class="line"><span class="keyword">decltype</span>(x+y) z = x + y; 	<span class="comment">// z - &gt;  int	</span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; i = x;</span><br><span class="line"><span class="keyword">decltype</span>(i) j = y;			<span class="comment">// j -&gt; const int&amp;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">const</span> <span class="title">decltype</span><span class="params">(z)</span> *p </span>= &amp;z;	<span class="comment">// p-&gt; const int *</span></span><br><span class="line"><span class="keyword">decltype</span>(z) *pi = &amp;z; 		<span class="comment">// pi -&gt; int*</span></span><br><span class="line"><span class="keyword">decltype</span>(pi) *pp = π		<span class="comment">//pp -&gt; int**</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x;      <span class="comment">//sum的类型就是函数f返回的类型</span></span><br></pre></td></tr></table></figure>
<p>auto与decltype类似但是又不同，auto只能根据变量的初始化表达式推导出变量应该具有的类型。decltype将精确的推导出表达式定义的类型，不会舍弃和弃用cv限定符。</p>
<p>一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(*p) c; <span class="comment">//错误！解引用表达式，c的类型为引用，需要初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(i) e; <span class="comment">//正确，e是一个未初始化的int</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d; <span class="comment">//错误！d是int&amp;类型，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(((i))) d1 = i; <span class="comment">//正确，d1是int&amp;类型，且已初始化</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义数据结构、类和头文件"><a href="#自定义数据结构、类和头文件" class="headerlink" title="自定义数据结构、类和头文件"></a>自定义数据结构、类和头文件</h2><p>类定义可以使用关键字<code>class</code>或<code>struct</code>，二者默认的继承、访问权限不同，<code>struct</code>是<code>public</code>的，<code>class</code>是<code>private</code>的。</p>
<p>编写自己的头文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SALES_DATA_H <span class="comment">//习惯大写</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALES_DATA_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>函数的声明应该放在头文件中，内联函数的定义也应该放在头文件中。</strong></p>
<p>【实例】分离式编译：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chapter6.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CHAPTER6_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHAPTER6_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// CHAPTER6_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fact.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Chapter6.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(val==<span class="number">0</span> || val==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> val * <span class="built_in">fact</span>(val<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// factMain.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Chapter6.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;input an int num: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">&quot;! = &quot;</span> &lt;&lt; <span class="built_in">fact</span>(num) &lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://bu.dusays.com/2023/03/25/641eec8577c68.png" alt="17-1dot5.png"></p>
<p>如上图，在终端中输入以下命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ factMain.cpp fact.cpp <span class="literal">-o</span> scexamp</span><br></pre></td></tr></table></figure>
<h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p><img src="https://s2.loli.net/2022/11/25/HXwmQflsYF41znv.png" alt="17-2.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string s1,s2;</span><br><span class="line">cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">cout&lt;&lt;s1&lt;&lt;s2&lt;&lt;endl;</span><br><span class="line"><span class="comment">//输入：hello world</span></span><br><span class="line"><span class="comment">//输出：helloworld</span></span><br><span class="line"><span class="comment">//s1装的是hello，s2是world</span></span><br></pre></td></tr></table></figure>
<p><code>getline</code>得到的<code>string</code>对象不包含换行符:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="comment">//每次读入一整行，包括空白，直到文件末尾</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin,line))&#123;</span><br><span class="line">        cout&lt;&lt;line&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字面值和<code>string</code>对象相加：</p>
<p><img src="https://s2.loli.net/2022/11/25/yMczalb4n3OQCLm.png" alt="17-3.png"></p>
<p><code>cctype</code>中的一些函数：</p>
<p><img src="https://s2.loli.net/2022/11/25/b9YDqtAjkcyR2M5.png" alt="17-4.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(string::size_type i=<span class="number">0</span>; i!=s.<span class="built_in">size</span>(); i=i+<span class="number">2</span>)</span><br><span class="line">    s[i]=<span class="string">&#x27;x&#x27;</span>;  <span class="comment">//一个使用string::size_type的例子</span></span><br></pre></td></tr></table></figure>
<p>从逻辑上讲，<code>size()</code>成员函数应该似乎返回整型数值，但事实上，size操作返回是<code>string::size_type</code>类型的值。string类类型和其他许多库类型都定义了一些配套类型（companion type）。通过这些配套类型，库函数的使用就与机器无关（machine-independent）。size_type就是这些配套类型中的一种。它定义为与unsigned型（<code>unsigned int</code>或<code>unsigned long</code>）具有相同含义，而且保证足够大的能够存储任意的string对象的长度。<code>string::size_type</code>在不同的机器上长度可以不同，并非固定。但只要使用该类型，就使得程序适合机器。string对象的索引也应为size_type类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序例子</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World!!!&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">decltype</span>(s.<span class="built_in">size</span>())punct_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123; <span class="comment">//for every char in s</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">ispunct</span>(c))++punct_cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    string orig = s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : s)&#123; <span class="comment">//需要修改字符串s</span></span><br><span class="line">        c = <span class="built_in">toupper</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p><img src="https://s2.loli.net/2022/11/25/jYlGPQ4V6nuig8J.png" alt="17-5.png"></p>
<p>访问<code>vector</code>的一种方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i : v)&#123; <span class="comment">//与上例类似</span></span><br><span class="line">        i*=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : v)&#123;</span><br><span class="line">        std::cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/11/25/2JFIf4hT1QczuP3.png" alt="17-6.png"></p>
<h2 id="迭代器（iterator）"><a href="#迭代器（iterator）" class="headerlink" title="迭代器（iterator）"></a>迭代器（iterator）</h2><p>有迭代器的类型都拥有<code>begin</code>和<code>end</code>成员。如果容器为空，则<code>begin</code>和<code>end</code>返回的是同一个迭代器，都是<code>尾后迭代器</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = v.<span class="built_in">begin</span>(), e = v.<span class="built_in">end</span>();</span><br><span class="line"><span class="comment">//b表示v的第一个元素，e表示v尾元素的下一位置</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/12/01/YQj2wMSRmpxkAZ8.png" alt="17-7.png"></p>
<p>迭代器类型，<code>iterator</code>和<code>const_iterator</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it; <span class="comment">//it能读写vector&lt;int&gt;元素</span></span><br><span class="line">string::iterator it2; <span class="comment">//it2能读写string对象中的字符</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator it3; <span class="comment">//it3只能读，不能写</span></span><br><span class="line">string::const_iterator it4; <span class="comment">//it4只能读，不能写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----分--割--线--QAQ-----*/</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> it1 = v.<span class="built_in">begin</span>(); <span class="comment">//it1的类型是vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.<span class="built_in">begin</span>(); <span class="comment">//it2的类型是vector&lt;int&gt;::const_iterator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-----分--割--线--QAQ-----*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//有时我们希望即使对象不是常量，也使用const_iterator，</span></span><br><span class="line"><span class="comment">//C++11引入了cbegin和cend</span></span><br><span class="line"><span class="keyword">auto</span> it3 = v.<span class="built_in">cbegin</span>(); <span class="comment">//it3的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure>
<p>结合解引用的成员访问：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v;</span><br><span class="line"><span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">(*it).<span class="built_in">empty</span>();</span><br><span class="line">*it.<span class="built_in">empty</span>(); <span class="comment">//错误！</span></span><br><span class="line">it-&gt;<span class="built_in">empty</span>(); <span class="comment">//箭头运算符：把解引用和成员访问两个操作合在一起</span></span><br></pre></td></tr></table></figure>
<p><strong>任何一种可能改变vector对象容量的操作，都会使得相应的迭代器失效。</strong></p>
<p>迭代器运算：</p>
<p><img src="https://s2.loli.net/2022/12/01/Dh14EGjnps7Kf6H.png" alt="17-8.png"></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>一种写法：<code>int a[]=&#123;1,2,3&#125;;</code>，<code>[]</code>内可以不填数字。</p>
<p>字符数组的特殊性：字符串字面值的结尾处有一个空字符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a1[] = &#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;; <span class="comment">//列表初始化，没有空字符</span></span><br><span class="line"><span class="type">char</span> a2[] = &#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">//列表初始化，显式写出了空字符</span></span><br><span class="line"><span class="type">char</span> a3[] = <span class="string">&quot;C++&quot;</span>; <span class="comment">//将自动包含空字符</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> a4[<span class="number">6</span>] = <span class="string">&quot;Danial&quot;</span>; <span class="comment">//错误！没有空间放空字符</span></span><br></pre></td></tr></table></figure>
<p>复杂的数组声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptrs[<span class="number">10</span>]; <span class="comment">//ptrs是含有10个整型指针的数组</span></span><br><span class="line"><span class="type">int</span> &amp;refs[<span class="number">10</span>] = <span class="comment">/* ？ */</span>; <span class="comment">//错误！不存在引用的数组</span></span><br><span class="line"><span class="built_in">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr; <span class="comment">//Parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="built_in">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr; <span class="comment">//arrRef引用一个含有10个整数的数组</span></span><br><span class="line"><span class="type">int</span> *(&amp;arry)[<span class="number">10</span>] = ptrs; <span class="comment">//arry是数组的引用，该数组含有10个指针</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/12/12/MzaSUBXNf5W8rdi.png" alt="17-9.png"></p>
<p>数组的<code>begin</code>和<code>end</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p1 = std::<span class="built_in">begin</span>(a);</span><br><span class="line">    <span class="type">int</span> *p2 = std::<span class="built_in">end</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;p1 != p2; p1++)&#123;</span><br><span class="line">        std::cout&lt;&lt;*p1&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-----运行结果-----</span></span><br><span class="line"><span class="comment">1 2 3 4</span></span><br><span class="line"><span class="comment">-----------------*/</span></span><br></pre></td></tr></table></figure>
<p>指针运算：</p>
<p><img src="https://s2.loli.net/2022/12/12/t3onZmyICzw1viH.png" alt="17-10.png"></p>
<p>下标和指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = &amp;ia[<span class="number">2</span>]; <span class="comment">// 指向“4”</span></span><br><span class="line"><span class="type">int</span> j = p[<span class="number">1</span>]; <span class="comment">// j = 6</span></span><br><span class="line"><span class="type">int</span> k = p[<span class="number">-2</span>]; <span class="comment">// k = 0  , string和vector的下标不可以为负</span></span><br></pre></td></tr></table></figure>
<p>C风格字符串：处理函数定义在<code>cstring</code>头文件中。</p>
<p><img src="https://bu.dusays.com/2023/01/03/63b3fb10a29b4.png" alt="17-11.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ca[]=&#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;+&#x27;</span>&#125;;</span><br><span class="line">cout&lt;&lt;<span class="built_in">strlen</span>(ca)&lt;&lt;endl; <span class="comment">//错误！ca[]没有以 &#x27;\0&#x27; 结束</span></span><br></pre></td></tr></table></figure>
<p>与旧代码的接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">char</span> *str = s; <span class="comment">//错误！不能这样用</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str = s.<span class="built_in">c_str</span>(); <span class="comment">//正确，c风格的string</span></span><br></pre></td></tr></table></figure>
<p>使用数组初始化<code>vector</code>对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> int_arr[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(std::begin(int_arr),std::end(int_arr))</span></span>;</span><br><span class="line"><span class="comment">// 左闭右开</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">subVec</span><span class="params">(int_arr+<span class="number">1</span>,int_arr+<span class="number">4</span>)</span></span>; <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>将所有元素初始化为0：<code>int arr[10][20][30]=&#123;0&#125;;</code></p>
<p>初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia2[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br><span class="line">&#125;;              <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> ia3[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> ia4[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">4</span>&#125;,&#123;<span class="number">8</span>&#125;&#125;; <span class="comment">// &#123;0,0,0,0,4,0,0,0,8,0,0,0&#125;</span></span><br><span class="line"><span class="type">int</span> ia5[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;     <span class="comment">// &#123;0,3,6,9,0,0,0,0,0,0,0,0&#125;</span></span><br></pre></td></tr></table></figure>
<p>下标引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>]; <span class="comment">//把row绑定到ia的第二个4元素数组上</span></span><br></pre></td></tr></table></figure>
<p>使用范围for语句处理多维数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : ia)        <span class="comment">//对于外层数组的每一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;col : row) &#123; <span class="comment">//对于内层数组的每一个元素</span></span><br><span class="line">        col = cnt;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*----------------------</span></span><br><span class="line"><span class="comment">在上面的例子中，因为要改变数组元素的值，所以使用引用类型。</span></span><br><span class="line"><span class="comment">对于没有写操作的，可以参考下例：避免数组被自动转成指针</span></span><br><span class="line"><span class="comment">----------------------*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;row : ia)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> col : row)</span><br><span class="line">        cout &lt;&lt; col &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>指针和多维数组：</p>
<p><img src="https://bu.dusays.com/2023/01/04/63b4f8690ecd0.png" alt="17-12"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p指向含有4个整数的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p=ia; p!=ia+<span class="number">3</span>; p++)&#123;</span><br><span class="line">    <span class="comment">//q指向4个整数数组的首元素，也就是说，q指向一个整数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> q=*p; q!=*p+<span class="number">4</span>; q++)</span><br><span class="line">        cout &lt;&lt; *q &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型别名简化多维数组的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和上例一样</span></span><br><span class="line"><span class="keyword">using</span> int_array = <span class="type">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (int_array *p = ia; p!=ia+<span class="number">3</span>; p++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> *q = *p; q!=*p+<span class="number">4</span>; q++)</span><br><span class="line">        cout &lt;&lt; *q &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="表达式基础"><a href="#表达式基础" class="headerlink" title="表达式基础"></a>表达式基础</h2><p>概念：左值和右值，上网查。</p>
<p>如果表达式的求值结果是左值，<code>decltype</code>作用于该表达式（不是变量）得到一个引用类型。例如，对于<code>int *p</code>：</p>
<ul>
<li>因为解引用运算符生成左值，所以<code>decltype(*p)</code>的结果是<code>int&amp;</code></li>
<li>因为取地址运算符生成右值，所以<code>decltype(&amp;p)</code>的结果是<code>int **</code></li>
</ul>
<p><strong>如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。</strong></p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><code>m%(-n)</code>等于<code>m%n</code>，<code>(-m)%n</code>等于<code>-(m%n)</code>。</p>
<h2 id="成员访问、条件、位运算符"><a href="#成员访问、条件、位运算符" class="headerlink" title="成员访问、条件、位运算符"></a>成员访问、条件、位运算符</h2><p>成员访问运算符，<code>ptr-&gt;mem</code>等价于<code>(*ptr).mem</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;a string&quot;</span>, *p = &amp;s1;</span><br><span class="line"><span class="keyword">auto</span> n = s1.<span class="built_in">size</span>();</span><br><span class="line">n = (*p).<span class="built_in">size</span>();</span><br><span class="line">n = p-&gt;<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
<p>位运算符作用于整数类型。关于符号位如何处理没有明确的规定，所以强烈<strong>建议仅将位运算符用于处理无符号类型</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设char占8位，int占32位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> bits = <span class="number">0233</span>; <span class="comment">//八进制，二进制为 10011011</span></span><br><span class="line">bits &lt;&lt; <span class="number">8</span>; <span class="comment">//bits提升为int型，然后左移8位</span></span><br></pre></td></tr></table></figure>
<p>使用位运算符：假设班级中有30个学生，用一个二进制位表示某个学生在测试中是否通过。例子如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> quizl = <span class="number">0</span>;</span><br><span class="line">quizl |= <span class="number">1UL</span> &lt;&lt; <span class="number">27</span>; <span class="comment">//学生27通过了测试</span></span><br><span class="line">quizl &amp;= ~(<span class="number">1UL</span> &lt;&lt; <span class="number">27</span>); <span class="comment">//学生27没有通过测试</span></span><br><span class="line"><span class="type">bool</span> status = quizl &amp; (<span class="number">1UL</span> &lt;&lt; <span class="number">27</span>); <span class="comment">//查询学生27是否通过了测试</span></span><br></pre></td></tr></table></figure>
<h2 id="sizeof和逗号运算符"><a href="#sizeof和逗号运算符" class="headerlink" title="sizeof和逗号运算符"></a>sizeof和逗号运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sales_data data, *p;</span><br><span class="line"><span class="built_in">sizeof</span>(Sales_data); <span class="comment">// Sales_data类型的对象所占空间的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> data; <span class="comment">//和上一行结果一样</span></span><br><span class="line"><span class="keyword">sizeof</span> *p;   <span class="comment">//和上一行结果一样</span></span><br><span class="line"><span class="keyword">sizeof</span> p; <span class="comment">//指针所占空间的大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span> data.revenue; <span class="comment">//对象里的成员的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> Sales_data::revenue; <span class="comment">//C++11，和上一行结果一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sizeof运算能够得到整个数组的大小</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> sz = <span class="built_in">sizeof</span>(ia) / <span class="built_in">sizeof</span>(*ia);</span><br><span class="line"><span class="type">int</span> arr2[sz]; <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>看看就好，一般不用：</p>
<p><img src="https://bu.dusays.com/2023/01/06/63b7acd5aa3a6.png" alt="17-13.png"></p>
<p>指针的转换：</p>
<ul>
<li><code>0</code>或字面值<code>nullptr</code>能够转换成任意指针类型</li>
<li>指向任意非常量的指针能够转换成<code>void*</code></li>
<li>指向任意对象的指针能够转换成<code>const void*</code></li>
</ul>
<p>显式转换：强制转换<code>cast-name&lt;type&gt;(expression)</code>，<code>cast-name</code>是<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code>中的一种。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="type">double</span> slope = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(j) / i;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> d;</span><br><span class="line"><span class="type">void</span> *p = &amp;d;</span><br><span class="line"><span class="type">double</span> *dp = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(p); <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<p><code>const_cast</code>只能改变运算对象的底层<code>const</code>，对于将常量对象转换成非常量对象的行为，称为『去掉const性质（cast away the const）』。</p>
<p><code>const_cast</code>可以移除底层<code>const</code>，或是给普通的类型添加底层<code>const</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *cp = &amp;a;</span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(cp);</span><br><span class="line">    *p = <span class="number">4</span>;  <span class="comment">//允许</span></span><br><span class="line">    cout &lt;&lt; a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------- 对 比 ---------*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *cp = &amp;a;</span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(cp);</span><br><span class="line">    *p = <span class="number">4</span>; <span class="comment">//没有定义</span></span><br><span class="line">    cout &lt;&lt; a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>static_cast</code>不能去掉const性质。<code>const_cast</code>不能改变类型。</p>
<p><code>reinterpret_cast</code>通常为运算对象的位模式提供较低层次上的重新解释。</p>
<p><img src="https://bu.dusays.com/2023/01/07/63b859b8c8e1e.png" alt="17-14.png"></p>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p><code>switch-case</code>,case标签必须是整型（小整型、bool型、short、char也都可以）常量表达式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关于switch-case里面的初始化的一个例子</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">switch</span>(<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="type">int</span> c; <span class="comment">//不能初始化！</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;before c = &quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">            c = <span class="number">1</span>; <span class="comment">//在case1中声明并定义的c可以在这里使用</span></span><br><span class="line">            <span class="type">int</span> a = <span class="number">1</span>; <span class="comment">//用大括号括起来，则可以初始化</span></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;after c = &quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h2><p>范围<code>for</code>语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//范围变量必须是引用类型，这样才能对元素执行写操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;r : v)&#123;</span><br><span class="line">    r *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------- 对 比 ---------*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> beg=v.<span class="built_in">begin</span>(),end=v.<span class="built_in">end</span>(); beg!=end; ++beg)&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = *beg; <span class="comment">//r是引用类型才能对元素执行写操作</span></span><br><span class="line">    r *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><p><code>goto</code>语句：无条件跳转到同一函数内的另一条语句。一般情况下不要使用<code>goto</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">    <span class="type">int</span> ix = <span class="number">10</span>; <span class="comment">//错误！goto语句绕过了一个带初始化的变量定义</span></span><br><span class="line">end:</span><br><span class="line">    <span class="comment">//错误！此处的代码需要使用ix</span></span><br><span class="line">    ix = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向后跳过一个初始化的变量定义是合法的</span></span><br><span class="line">begin:</span><br><span class="line">    <span class="type">int</span> sz = <span class="built_in">get_size</span>();</span><br><span class="line">    <span class="keyword">if</span>(sz&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">goto</span> begin; <span class="comment">//goto语句执行后，将销毁sz</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>运行时的反常行为，例如读取或写入数据时失去数据库链接。</p>
<p><code>throw</code>表达式：异常检测部分使用<code>throw</code>表达式来表示它遇到了无法解决的问题。</p>
<p><code>runtime_error</code>是标准库异常类型的一种，定义在<code>stdexcept</code>头文件。它抛出一个异常，终止当前的函数，并把控制权交给处理异常的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于简单的小程序</span></span><br><span class="line">Sales_item item1,item2;</span><br><span class="line">cin &gt;&gt; item1 &gt;&gt; item2;</span><br><span class="line"><span class="keyword">if</span>(item1.<span class="built_in">isbn</span>() == item2.<span class="built_in">isbn</span>())&#123;</span><br><span class="line">    cout &lt;&lt; item1+item2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//表示成功</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Data must refer to same ISBN&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//表示失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------------- 对 比 -----------------*/</span></span><br><span class="line"><span class="keyword">if</span> (item1.<span class="built_in">isbn</span>() != item2.<span class="built_in">isbn</span>())&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Data must refer to same ISBN&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果程序执行到这里，表示两个ISBN是相同的</span></span><br><span class="line">cout &lt;&lt; item1+item2 &lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p><code>try</code>语句块：异常处理部分使用<code>try</code>语句块处理异常，可以有一个或多个<code>catch</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin&gt;&gt;item1&gt;&gt;item2)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//执行添加两个Sales_item对象的代码</span></span><br><span class="line">        <span class="comment">//如果添加失败，代码抛出一个runtime_error异常</span></span><br><span class="line">    &#125;<span class="built_in">catch</span>(runtime_error err)&#123;</span><br><span class="line">        <span class="comment">//提醒用户两个ISBN必须一致，询问是否重新输入</span></span><br><span class="line">        cout &lt;&lt; err.<span class="built_in">what</span>() <span class="comment">//返回初始化对象时填入的参数（const char*）</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;\nTry Again? Enter y or n&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span> (!cin || c==<span class="string">&#x27;n&#x27;</span>) <span class="keyword">break</span>; <span class="comment">//跳出while</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一套异常类：<code>throw</code>表达式和相关的<code>catch</code>子句之间传递异常的具体信息。这些异常分别定义在4个头文件中：</p>
<ul>
<li><code>exception</code>头文件：最通用的异常类<code>exception</code>，只报告异常的发生，不提供额外信息</li>
<li><code>stdexcept</code>头文件：定义了几种常用的异常类</li>
<li><code>new</code>头文件：<code>bad_alloc</code>异常类</li>
<li><code>type_info</code>头文件：<code>bad_cast</code>异常类</li>
</ul>
<h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>局部对象：</p>
<ul>
<li>自动对象：生命周期从变量声明开始，到函数块末尾结束</li>
<li>局部静态对象：生命周期从变量声明开始，直到程序结束才销毁</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count_calls</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a; <span class="comment">//自动对象</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> ctr = <span class="number">0</span>; <span class="comment">//局部静态对象</span></span><br><span class="line">    <span class="keyword">return</span> ++ctr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>指针型变量在函数体中需要被改变的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> *&amp;x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一维数组作为参数，除了将数组名传入函数外，为了规范化，还要将数组的大小作为参数传入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_arr</span> <span class="params">(<span class="type">int</span> att[] , <span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组名是首元素的地址，因此还可以写成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_arr</span> <span class="params">(<span class="type">int</span> *att , <span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">   <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管是哪种定义，使用函数时都是将数组名作为参数，比如：<code>sum_arr (Ss , 66);</code>。在函数内部对传入的数组进行修改，该数组本身的值也会改变。</p>
<p>若要防止在函数中修改数组，可以使用<code>const</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_arr</span> <span class="params">(<span class="type">const</span> <span class="type">int</span> att[] , <span class="type">int</span> size)</span></span></span><br></pre></td></tr></table></figure>
<p>前面将数组的首元素的地址和长度传入，这样就可以处理所有元素。C++中引入了新的方式，即数组区间：传入数组的首元素地址和末尾地址，参数就是【数组名，数组名+长度】，这样也可以处理所有元素。进一步，也可以传入任意区间。例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_arr</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *begin,<span class="type">const</span> <span class="type">int</span> *end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *pt;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(pt = begin ; pt != end ; pt++)</span><br><span class="line">    &#123;</span><br><span class="line">        total = total + *pt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A[Size] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125; ;</span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">sum_arr</span>(A,A+<span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>二维数组作为参数，与一维类似，有两种声明方式，但有所区别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> A[ ][<span class="number">4</span>] , <span class="type">int</span> size)</span> <span class="comment">//不能写成 int sum(int A[ ][ ] , int size)，必须将列数写进去，size的值是行数</span></span></span><br><span class="line"><span class="function"><span class="comment">//下面一种写法看看就好：</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> (*A)[<span class="number">4</span>] , <span class="type">int</span> size)</span> <span class="comment">//同样，必须将列数写进去，size的值是行数，而且必须要将*和数组名括起来。</span></span></span><br></pre></td></tr></table></figure>
<p>至于使用方法都是一样，<code>sum(A，4);</code>。第二维长度有较严格的要求：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x[][<span class="number">5</span>] , <span class="type">int</span> mysize)</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>][<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">10</span>][<span class="number">3</span>];</span><br><span class="line"><span class="built_in">f</span>(a,<span class="number">10</span>); <span class="comment">//正确</span></span><br><span class="line"><span class="built_in">f</span>(b,<span class="number">10</span>); <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>
<p>如果函数无需改变引用形参的值，最好将其声明为常量引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isShorter</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++允许将变量定义为数组的引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确：形参是数组的引用，维度是类型的一部分</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">10</span>])</span></span>&#123; <span class="comment">// ()不能少</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> elem : arr)&#123;</span><br><span class="line">        cout&lt;&lt;elem&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main</code>处理命令行选项。有时需要给<code>main</code>传实参，一种常见的情况是用户设置一组选项来确定函数所要执行的操作。例如，假定<code>main</code>函数位于可执行文件<code>prog</code>内，可以向程序传递下面的选项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog -d -o ofile data0</span><br></pre></td></tr></table></figure>
<p>这些命令行选项通过两个（可选的）形参传递给<code>main</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;<span class="comment">/* do something */</span>&#125;</span><br><span class="line"><span class="comment">/* 第二个形参argv是一个数组，它的元素是指向C风格字符串的指</span></span><br><span class="line"><span class="comment">针；第一个形参argc表示数组中字符串的数量。因为第二个形参是</span></span><br><span class="line"><span class="comment">数组，所以main函数也可以定义成如下的方式： */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;<span class="comment">/* do something */</span>&#125;</span><br><span class="line"><span class="comment">//其中argv指向char*</span></span><br></pre></td></tr></table></figure>
<p>以上面提供的命令行为例，<code>argc</code>应该等于5，<code>argv</code>应该包含如下的C风格字符串：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;prog&quot;</span>; <span class="comment">//或者argv[0]也可以指向一个空字符串</span></span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;-d&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="string">&quot;-o&quot;</span>;</span><br><span class="line">argv[<span class="number">3</span>] = <span class="string">&quot;ofile&quot;</span>;</span><br><span class="line">argv[<span class="number">4</span>] = <span class="string">&quot;data0&quot;</span>;</span><br><span class="line">argv[<span class="number">5</span>] = <span class="number">0</span>; <span class="comment">//最后一个指针之后的元素值保证为 0</span></span><br></pre></td></tr></table></figure>
<p>含有可变形参的函数：参数个数不固定。如果所有的实参类型相同，可以传递一个名为<code>initializer_list</code>的标准库类型。</p>
<p><img src="https://bu.dusays.com/2023/01/09/63bbb301623b0.png" alt="17-15.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和vector不一样，initializer_list对象中的元素永远是常量值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_msg</span><span class="params">(initializer_list&lt;string&gt; il)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> beg=il.<span class="built_in">begin</span>(); beg!=il.<span class="built_in">end</span>(); ++beg)&#123;</span><br><span class="line">        cout&lt;&lt;*beg&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//excepted和actual是string对象</span></span><br><span class="line"><span class="keyword">if</span>(excepted!=actual)</span><br><span class="line">    <span class="built_in">error_msg</span>(&#123;<span class="string">&quot;functionX&quot;</span>,excepted,actual&#125;);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">error_msg</span>(&#123;<span class="string">&quot;functionX&quot;</span>,<span class="string">&quot;okey&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>省略符形参：上网查。</p>
<h2 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h2><p><strong>不要</strong>返回局部对象的引用或指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//严重错误：这个函数试图返回局部对象的引用</span></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">manip</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string ret;</span><br><span class="line">    <span class="comment">//以某种方式改变一下ret</span></span><br><span class="line">    <span class="keyword">if</span>(!ret.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> ret;     <span class="comment">//错误！返回局部对象的引用</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Empty&quot;</span>; <span class="comment">//错误！&quot;Empty&quot;是一个局部临时变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>列表初始化返回值（C++11）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//expected和actual是string对象</span></span><br><span class="line">    <span class="keyword">if</span>(expected.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;; <span class="comment">//返回一个空vector对象</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(expected==actual)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;functionX&quot;</span>,<span class="string">&quot;okay&quot;</span>&#125;; <span class="comment">//返回列表初始化的vector对象</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;functionX&quot;</span>,expected,actual&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>main</code>的返回值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一种写法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span>(some_failure)</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE; <span class="comment">//定义在cstdlib头文件中</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS; <span class="comment">//同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://bu.dusays.com/2023/01/11/63becdd957edf.png" alt="17-16.png"></p>
<p><img src="https://bu.dusays.com/2023/01/09/63bc1b6ef129c.png" alt="17-17.png"></p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数重载：函数名称相同但形参列表不同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account&amp;)</span></span>; <span class="comment">//错误！有第一行的情况下不能这么写</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Phone&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Name&amp;)</span></span>;</span><br><span class="line">Account acct;</span><br><span class="line">Phone phone;</span><br><span class="line">Record r1 = <span class="built_in">lookup</span>(acct);</span><br><span class="line">Record r2 = <span class="built_in">lookup</span>(phone);</span><br></pre></td></tr></table></figure>
<p><code>const_cast</code>和重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较两个string对象的长度，返回较短的那个引用</span></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>()&lt;=s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string &amp;<span class="title">shorterString</span><span class="params">(string &amp;s1, string &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = <span class="built_in">shorterString</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s1),</span><br><span class="line">                            <span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【实例】 函数重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;该函数无须参数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;该函数有一个整型参数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;该函数有两个整型参数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b=<span class="number">3.14</span>)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;该函数有两个双精度浮点型参数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">2.56</span>, <span class="number">42.0</span>);</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">42</span>);</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">42</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">2.56</span>, <span class="number">3.14</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Active code page: <span class="number">65001</span></span><br><span class="line"><span class="built_in">PS</span> C:\Users\arrogance&gt; <span class="built_in">cd</span> <span class="string">&quot;d:\c++code\&quot;</span></span><br><span class="line"><span class="built_in">PS</span> D:\c++code&gt; <span class="keyword">if</span> (<span class="variable">$</span>?) &#123; g++ test.cpp <span class="literal">-o</span> test &#125; ; <span class="keyword">if</span> (<span class="variable">$</span>?) &#123; .\test &#125;</span><br><span class="line">该函数有两个双精度浮点型参数</span><br><span class="line">该函数有一个整型参数</span><br><span class="line">该函数有两个整型参数</span><br><span class="line">该函数有两个双精度浮点型参数</span><br></pre></td></tr></table></figure>
<h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><p>默认实参：一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string::size_type sz;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz ht=<span class="number">24</span>, sz wid=<span class="number">80</span>, <span class="type">char</span> backgrnd=<span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">string mwindow;</span><br><span class="line">mwindow = <span class="built_in">screen</span>(); <span class="comment">//等价于screen(24,80,&#x27; &#x27;)</span></span><br><span class="line">mwindow = <span class="built_in">screen</span>(<span class="number">66</span>); <span class="comment">//等价于screen(66,80,&#x27; &#x27;)</span></span><br><span class="line">mwindow = <span class="built_in">screen</span>(<span class="number">66</span>,<span class="number">256</span>); <span class="comment">//screen(66,256,&#x27; &#x27;)</span></span><br><span class="line">mwindow = <span class="built_in">screen</span>(<span class="number">66</span>,<span class="number">256</span>,<span class="string">&#x27;#&#x27;</span>); <span class="comment">//screen(66,256,&#x27;#&#x27;)</span></span><br><span class="line"></span><br><span class="line">mwindow = <span class="built_in">screen</span>(,,<span class="string">&#x27;?&#x27;</span>); <span class="comment">//错误！只能省略尾部的实参</span></span><br><span class="line">mwindow = <span class="built_in">screen</span>(<span class="string">&#x27;?&#x27;</span>); <span class="comment">//会发生隐式转换</span></span><br></pre></td></tr></table></figure>
<p><code>constexpr</code>函数：能用于常量表达式的函数，函数的返回类型及所有的形参都是字面值类型。</p>
<ul>
<li>函数体中必须有且仅有一条<code>return</code>语句</li>
<li><code>constexpr</code>函数被隐式地指定为内联函数</li>
<li><code>constexpr</code>函数并不要求返回常量表达式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">new_sz</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> foo = <span class="built_in">new_sz</span>(); <span class="comment">//正确，foo是一个常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">scale</span><span class="params">(<span class="type">size_t</span> cnt)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">new_sz</span>()*cnt;&#125;</span><br><span class="line"><span class="type">int</span> arr[<span class="built_in">scale</span>(<span class="number">2</span>)]; <span class="comment">//正确，scale(2)是常量表达式</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> a2[<span class="built_in">scale</span>(i)]; <span class="comment">//错误！scale(i)不是常量表达式</span></span><br></pre></td></tr></table></figure>
<p>调试帮助：只在开发过程中使用的代码，发布时屏蔽掉。</p>
<p><code>assert</code>预处理宏，位于<code>cassert</code>头文件中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果表达式为假，assert输出信息并终止程序的执行</span></span><br><span class="line"><span class="comment">//如果表达式为真，assert什么也不做</span></span><br><span class="line"><span class="built_in">assert</span>(word.<span class="built_in">size</span>()&gt;threshold);</span><br></pre></td></tr></table></figure>
<p><code>NDEBUG</code>预处理变量：<code>assert</code>的行为依赖<code>NDEBUG</code>预处理变量的状态，如果定义了<code>NDEBUG</code>，则<code>assert</code>无效。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG <span class="comment">//关闭调试状态，必须在cassert头文件上面</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>除了用于<code>assert</code>外，也可以使用<code>NDEBUG</code>编写自己的调试代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ia[], <span class="type">size_t</span> size)</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="comment">//__func__是编译器定义的一个局部静态变量，用于存放函数的名字</span></span><br><span class="line">    cerr &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: array size is &quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://bu.dusays.com/2023/01/11/63bec9792c01a.png" alt="17-18.png"></p>
<h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><p>这一节看看就好，感觉用处不太。</p>
<p><img src="https://bu.dusays.com/2023/01/11/63becd3f25693.png" alt="17-19.png"></p>
<p>例子如下：</p>
<p><img src="https://bu.dusays.com/2023/01/11/63becd3f51959.png" alt="17-20.png"></p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针，指针指向的是函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;); <span class="comment">//括号不能少</span></span><br><span class="line"></span><br><span class="line">pf = lengthCompare;</span><br><span class="line">pf = &amp;lengthCompare; <span class="comment">//与上一行等价，取地址符是可选的</span></span><br><span class="line"><span class="comment">//可以直接使用指向函数的指针调用该函数，无需提前解引用</span></span><br><span class="line"><span class="comment">/*------------ 以下三行语句是等价的 ------------*/</span></span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">pf</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;goodbye&quot;</span>);</span><br><span class="line"><span class="type">bool</span> b2 = (*pf)(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;goodbye&quot;</span>);</span><br><span class="line"><span class="type">bool</span> b3 = <span class="built_in">lengthCompare</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;goodbye&quot;</span>);</span><br><span class="line"><span class="comment">/*--------------------------------------------*/</span></span><br></pre></td></tr></table></figure>
<p>在指向不同函数类型的指针间不存在转换规则（<strong>必须很精准的匹配才可以</strong>）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和上个例子连起来看</span></span><br><span class="line"><span class="function">string::size_type <span class="title">sumLength</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cstringCompare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*)</span></span>;</span><br><span class="line">pf = <span class="number">0</span>; <span class="comment">//正确，pf不指向任何函数</span></span><br><span class="line">pf = sumLength; <span class="comment">//错误！返回类型不匹配</span></span><br><span class="line">pf = cstringCompare; <span class="comment">//错误！形参类型不匹配</span></span><br><span class="line">pf = lengthCompare; <span class="comment">//正确，精确匹配</span></span><br></pre></td></tr></table></figure>
<p>函数指针形参：</p>
<p>不能定义函数类型的形参，但形参可以是指向函数的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三个形参是函数类型，它会自动地转换成指向函数的指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">bool</span> pf(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br><span class="line"><span class="comment">//等价的声明：显式地将形参定义成指向函数的指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以直接把函数作为实参使用，会自动转换成指针</span></span><br><span class="line"><span class="built_in">useBigger</span>(s1,s2,lengthCompare);</span><br></pre></td></tr></table></figure>
<p>通过使用类型别名，简化使用函数指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Func和Func2是函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">bool</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>; <span class="comment">//等价的类型</span></span><br><span class="line"><span class="comment">//FuncP和FuncP2是指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FuncP)</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncP2</span>; <span class="comment">//等价的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//useBigger的等价声明，其中使用了类型别名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;, Func)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string&amp;, <span class="type">const</span> string&amp;, FuncP2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>【练习6.54】 编写函数的声明，令其接受两个 int 形参并且返回类型也是 int ；然后声明一个 vector 对象，令其元素是指向该函数的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//满足题意的函数如下：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//满足题意的 vector 对象如下：</span></span><br><span class="line">vector&lt;<span class="keyword">decltype</span>(func)* &gt; vF;</span><br></pre></td></tr></table></figure>
<p>返回指向函数的指针：虽然不能返回一个函数，但是可以返回指向函数类型的指针。<strong>必须把返回类型写成指针形式，编译器不会自动处理。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="built_in">int</span>(<span class="type">int</span>*, <span class="type">int</span>); <span class="comment">//F是函数类型，不是指针</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="built_in">int</span>(*)(<span class="type">int</span>*, <span class="type">int</span>); <span class="comment">//PF是指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">//正确，PF是指向函数的指针，f1返回指向函数的指针</span></span><br><span class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;  <span class="comment">//错误！F是函数类型，f1不能返回一个函数</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>; <span class="comment">//正确，显式地指定返回类型是指向函数的指针</span></span><br></pre></td></tr></table></figure>
<p>也可以用下面的形式直接声明f1：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">f1</span>(<span class="type">int</span>)) (<span class="type">int</span>*, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p>从里往外读：<code>f1(int)</code>是一个函数，这个函数返回的是一个指针<code>(*f1(int))</code>，这个指针指向的是一个函数 <code>(int*, int)</code>，这个函数<code>(int*, int)</code>返回的是int型。</p>
<p>使用尾置返回类型的方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">int</span> <span class="params">(*)</span><span class="params">(<span class="type">int</span>*, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用尾置返回类型的其他例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 欲使函数返回数组的引用，该数组包含10个string对象</span></span><br><span class="line"><span class="built_in">string</span> (&amp;<span class="built_in">func</span>())[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">()</span> -&gt; <span class="title">string</span><span class="params">(&amp;)</span> [10]</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://bu.dusays.com/2023/01/12/63bfa6a382fb2.png" alt="17-21.png"></p>
<h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><p>考虑如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Sales_data的非成员接口函数</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;, Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>成员都必须在类的内部<strong>声明</strong>，但成员函数体可以<strong>定义</strong>在类内也可以在类外。</p>
<p>常量成员函数：类的成员函数后面加<code>const</code>，表明这个函数不会修改这个类对象的数据成员。</p>
<p>两种效果相同的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Sales_data内：</span></span><br><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo;&#125; <span class="comment">//尽管没有必要</span></span><br></pre></td></tr></table></figure>
<p>关于<code>this</code>的详细解释参考《C++ primer》。</p>
<p>编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。因此成员体可以随意使用类中的其他成员而无需在意这些成员出现的次序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在类的外部定义成员函数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Sales_data::avg_price</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(units_sold)</span><br><span class="line">        <span class="keyword">return</span> revenue/units_sold;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个返回<code>this</code>对象的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟复合运算符+=，为了和+=一致，返回为左值，因此需要返回引用</span></span><br><span class="line"><span class="function">Sales_data&amp; <span class="title">Sales_data::combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;rhs)</span></span>&#123; <span class="comment">//right hand side</span></span><br><span class="line">    units_sold += rhs.units_sold; <span class="comment">//把rhs的成员加到this对象的成员上</span></span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回调用该函数的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义类相关的非成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果非成员函数是类接口的组成部分，则应该与类在同一个头文件中声明</span></span><br><span class="line"><span class="comment">//IO对象不能拷贝，只能引用。 需要修改IO对象，不能用底层const</span></span><br><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">(istream &amp;is, Sales_data &amp;item)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.uints_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> Sales_data &amp;item)</span></span>&#123;</span><br><span class="line">    os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">       &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span></span>&#123;</span><br><span class="line">    Sales_data sum = lhs;</span><br><span class="line">    sum.<span class="built_in">combine</span>(rhs);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数：</p>
<ul>
<li>构造函数与类名同名，没有返回值，用来初始化类对象的数据成员。</li>
<li>类可以包括多个构造函数。</li>
<li>构造函数不能被声明为<code>const</code>的<ul>
<li>当我们创建类的一个<code>const</code>对象时，直到构造函数完成初始化，对象才能真正得到“常量”属性</li>
</ul>
</li>
</ul>
<p><strong>合成的默认构造函数（synthesized default constructor）</strong>：如果我们的类没有显式地定义构造函数，编译器会为我们隐式地定义一个默认构造函数。对于大多数类来说，这个『合成的默认构造函数』将按照如下规则初始化类的数据成员：</p>
<ul>
<li>若存在类内的初始值，用它来初始化成员。</li>
<li>否则，默认初始化该成员。</li>
</ul>
<p><strong>只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这段代码慢慢读不难懂，详细解释可以参阅《C++ primer》</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">    <span class="comment">//新增的构造函数</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s): <span class="built_in">bookNo</span>(s) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">               <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;);</span><br><span class="line">    <span class="comment">//之前已有的其他成员</span></span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//...之前的代码略</span></span><br><span class="line"><span class="comment">//在类的外部定义构造函数：</span></span><br><span class="line">Sales_data::<span class="built_in">Sales_data</span>(std::istream &amp;is)&#123;</span><br><span class="line">    <span class="built_in">read</span>(is, *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拷贝、赋值和析构：</p>
<p>管理动态内存的类通常不能依赖于编译器合成的版本。使用<code>vector</code>或<code>string</code>除外。</p>
<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>使用访问说明符加强类的封装性：</p>
<ul>
<li><code>public</code>：类的接口，在整个程序内可以被访问</li>
<li><code>private</code>：封装（即隐藏）类的实现细节</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class和struct定义类唯一的区别就是默认的访问权限不同</span></span><br><span class="line"><span class="comment">//struct默认public， class默认private</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">               <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s): <span class="built_in">bookNo</span>(s) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream&amp;);</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> units_sold ? revenue/units_sold : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或函数成为它的<strong>友元</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="comment">// 为Sales_data的非成员函数所做的友元声明</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> std::istream&amp; <span class="title">read</span><span class="params">(std::istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="comment">// 其他内容与之前一致</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">               <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s): <span class="built_in">bookNo</span>(s) &#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream&amp;);</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> units_sold ? revenue/units_sold : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Sales_data接口的非成员组成部分的声明</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::istream&amp; <span class="title">read</span><span class="params">(std::istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>友元声明只能出现在类定义的内部，但具体位置不限。友元不是类的成员，不受访问控制级别的约束。友元的声明仅指定访问的权限，不是通常意义上的函数声明。因此若希望类的用户能调用某个友元函数，最好在友元声明之外再对函数进行一次声明（有些编译器必须声明，有些可以省略。出于移植性的考虑，最好声明一下）。</p>
<h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><p>定义一个类型成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Screen表示显示器中的一个窗口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line">    <span class="comment">//等价于 using pos = std::string::size_type;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">    std::string contents;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这样做的原因是，Screen的用户不需要知道Screen使用了一个string对象来存放它的数据，pos隐藏了细节。</p>
<p>成员函数也支持重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line">    <span class="built_in">Screen</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Screen</span>(pos ht, pos wd, <span class="type">char</span> c): <span class="built_in">height</span>(ht),<span class="built_in">width</span>(wd),<span class="built_in">contents</span>(ht*wd,c)&#123;&#125;</span><br><span class="line">    <span class="comment">// string初始化的一种方法：使用单个字符初始化。</span></span><br><span class="line">    <span class="comment">// string s(10,&#x27;a&#x27;); //直接初始化，s的内容是aaaaaaaaaa</span></span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> contents[cursor];&#125; <span class="comment">// 隐式内联</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">get</span><span class="params">(pos ht, pos wd)</span> <span class="type">const</span></span>; <span class="comment">// 显式内联</span></span><br><span class="line">    <span class="function">Screen&amp; <span class="title">move</span><span class="params">(pos r, pos c)</span></span>;       <span class="comment">// 能在之后被设为内联</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">    std::string contents;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen&amp; <span class="title">Screen::move</span><span class="params">(pos r, pos c)</span></span>&#123;</span><br><span class="line">    pos row = r*width;</span><br><span class="line">    cursor = row+c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//以左值的形式返回对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">Screen::get</span><span class="params">(pos r, pos c)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    pos row = r*width;</span><br><span class="line">    <span class="keyword">return</span> contents[row+c];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可变数据成员（mutable data member）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">some_member</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">size_t</span> access_ctr; <span class="comment">//即使在一个const对象内也能被修改</span></span><br><span class="line">    <span class="comment">//其他成员与之前的版本一致，略</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::some_member</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    ++access_ctr; <span class="comment">//保存一个计数值，用于记录成员函数被调用的次数</span></span><br><span class="line">    <span class="comment">//该成员需要完成的其他工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类数据成员的初始值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window_mgr</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 这个窗口管理类，管理一组Screen</span></span><br><span class="line">    std::vector&lt;Screen&gt; screens&#123;<span class="built_in">Screen</span>(<span class="number">24</span>, <span class="number">80</span>, <span class="string">&#x27; &#x27;</span>)&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>返回<code>*this</code>的成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Screen&amp; <span class="title">set</span><span class="params">(<span class="type">char</span>)</span></span>;</span><br><span class="line">    <span class="function">Screen&amp; <span class="title">set</span><span class="params">(pos, pos, <span class="type">char</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 其他成员和之前的版本一致</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen&amp; <span class="title">Screen::set</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">    contents[cursor] = c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen&amp; <span class="title">Screen::set</span><span class="params">(pos r, pos col, <span class="type">char</span> ch)</span></span>&#123;</span><br><span class="line">    contents[r*width+col] = ch;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把光标移动到一个指定的位置，然后设置该位置的字符值</span></span><br><span class="line">    myScreen.<span class="built_in">move</span>(<span class="number">4</span>,<span class="number">0</span>).<span class="built_in">set</span>(<span class="string">&#x27;#&#x27;</span>);      <span class="comment">// 神之一手</span></span><br></pre></td></tr></table></figure>
<p>从<code>const</code>成员函数返回<code>*this</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//根据对象是否是const重载了display函数</span></span><br><span class="line">    <span class="function">Screen&amp; <span class="title">display</span><span class="params">(std::ostream &amp;os)</span></span>&#123;</span><br><span class="line">        <span class="built_in">do_display</span>(os);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> Screen&amp; <span class="title">display</span><span class="params">(std::ostream &amp;os)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="built_in">do_display</span>(os);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_display</span><span class="params">(std::ostream &amp;os)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        os &lt;&lt; contents;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他成员与之前的一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类的声明：我们可以仅声明类而暂时不定义它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>;   <span class="comment">// Screen类的声明</span></span><br></pre></td></tr></table></figure>
<p>这种声明也叫<strong>前向声明（forward declaration）</strong>，对于类型Screen来说，它在声明之后定义之前是一个<strong>不完全类型（incomplete type）</strong>，不完全类型只能在有限的情况下使用：</p>
<ul>
<li>可以定义指向这种类型的指针或引用</li>
<li>可以声明（但不能定义）以不完全类型作为参数或返回类型的函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Link_screen</span>&#123;</span><br><span class="line">    Link_screen *next; <span class="comment">//正确</span></span><br><span class="line">    Link_screen *prev; <span class="comment">//正确</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类之间的友元关系：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line">    <span class="comment">// Window_mgr的成员可以访问Screen类的私有部分</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Window_mgr</span>;</span><br><span class="line">    <span class="comment">// Screen类的剩余部分，略</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 如果一个类指定了友元类，则友元类的成员函</span></span><br><span class="line"><span class="comment">数可以访问此类包括非公有成员在内的所有成员。*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Window_mgr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 窗口中每个屏幕的编号</span></span><br><span class="line">    <span class="keyword">using</span> ScreenIndex = std::vector&lt;Screen&gt;::size_type;</span><br><span class="line">    <span class="comment">// 按编号将指定的Screen重置为空白</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Screen&gt; screens&#123;<span class="built_in">Screen</span>(<span class="number">24</span>, <span class="number">80</span>, <span class="string">&#x27; &#x27;</span>)&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex i)</span></span>&#123;</span><br><span class="line">    <span class="comment">// s是一个Screen的引用，指向我们想清空的那个屏幕</span></span><br><span class="line">    Screen &amp;s = screens[i];</span><br><span class="line">    s.contents = <span class="built_in">string</span>(s.height*s.width, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>友元关系不存在传递性。</strong></p>
<p>令成员函数作为友元：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line">    <span class="comment">// Window_mgr::clear必须在Screen类之前被声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line">    <span class="comment">// Screen类的剩余部分，略</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*-------------- 顺 序 ---------------*/</span></span><br><span class="line"><span class="comment">//1、定义Window_mgr类，声明clear函数，但不能定义它</span></span><br><span class="line"><span class="comment">//2、定义Screen，包括对于clear的友元声明</span></span><br><span class="line"><span class="comment">//3、定义clear，此时才能使用Screen的成员</span></span><br></pre></td></tr></table></figure>
<p>友元声明和作用域：参考《C++ Primer》</p>
<h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Screen::pos ht=<span class="number">24</span>, wd=<span class="number">80</span>; <span class="comment">//使用Screen类定义的pos类型</span></span><br><span class="line"><span class="function">Screen <span class="title">scr</span><span class="params">(ht, wd, <span class="string">&#x27; &#x27;</span>)</span></span>; <span class="comment">//创建了一个Screen对象并初始化</span></span><br><span class="line">Screen *p = &amp;scr;</span><br><span class="line"><span class="type">char</span> c = scr.<span class="built_in">get</span>(); <span class="comment">//访问scr对象的get成员</span></span><br><span class="line">c = p-&gt;<span class="built_in">get</span>(); <span class="comment">//访问所指对象的get成员</span></span><br></pre></td></tr></table></figure>
<p>对比以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> Window_mgr::clear<span class="comment">/*一旦遇到类名*/</span>(ScreenIndex i)&#123;</span><br><span class="line">    Screen &amp;s = screens[i];</span><br><span class="line">    s.contents = <span class="built_in">string</span>(s.height*s.width, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;   <span class="comment">//直到定义的结束，都是类的作用域之内</span></span><br><span class="line"><span class="comment">/*------------------ 对 比 ---------------------*/</span></span><br><span class="line"><span class="function">Window_mgr::ScreenIndex <span class="title">Window_mgr::addScreen</span><span class="params">(<span class="type">const</span> Screen &amp;s)</span></span>&#123;</span><br><span class="line">    screens.<span class="built_in">push_back</span>(s);</span><br><span class="line">    <span class="keyword">return</span> screens.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">&#125;   <span class="comment">//首先处理返回类型，之后才进入Window_mgr的作用域</span></span><br></pre></td></tr></table></figure>
<p>成员定义中的名字查找。以下代码仅作原理展示，不能作为作为写代码的满分参考（：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> height;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dummy_fcn</span><span class="params">(pos height)</span></span>&#123;</span><br><span class="line">        cursor = width*height;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//尽管外层的对象被隐藏了，但我们仍可以用作用域运算符访问它</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::dummy_fcn</span><span class="params">(pos height)</span></span>&#123;</span><br><span class="line">    cursor = width * <span class="keyword">this</span>-&gt;height; <span class="comment">//成员height</span></span><br><span class="line">    cursor = width * Screen::height; <span class="comment">//成员height</span></span><br><span class="line">    cursor = width * ::height; <span class="comment">//全局height</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><p>有时候初始化列表必不可少。如果成员是<code>const</code>、引用，或者属于某种未提供默认构造函数的类类型，必须通过构造函数初始列表提供初始值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstRef</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConstRef</span>(<span class="type">int</span> ii);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ci;</span><br><span class="line">    <span class="type">int</span> &amp;ri;</span><br><span class="line">&#125;;</span><br><span class="line">ConstRef::<span class="built_in">ConstRef</span>(<span class="type">int</span> ii)&#123;<span class="comment">//赋值：</span></span><br><span class="line">    i = ii;  <span class="comment">//正确</span></span><br><span class="line">    ci = ii; <span class="comment">//错误！</span></span><br><span class="line">    ri = i;  <span class="comment">//错误！ri没有初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确做法，显式地初始化引用和<code>const</code>成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConstRef::<span class="built_in">ConstRef</span>(<span class="type">int</span> ii):<span class="built_in">i</span>(ii), <span class="built_in">ci</span>(ii), <span class="built_in">ri</span>(i)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>成员初始化的顺序，构造函数初始值列表中的顺序不会影响实际的初始化顺序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> val):<span class="built_in">j</span>(val), <span class="built_in">i</span>(j)&#123;&#125; <span class="comment">//未定义的：i在j之前被初始化</span></span><br><span class="line">    <span class="comment">//尽量使用参数作为初始化值</span></span><br><span class="line">    <span class="comment">// X(int val):j(val), i(val)&#123;&#125;</span></span><br><span class="line">    <span class="comment">//这样就与i和j的初始化顺序无关了</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>默认实参和构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//定义默认构造函数，令其与只接受一个string实参的构造函数功能相同</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s = <span class="string">&quot;&quot;</span>):<span class="built_in">bookNo</span>(s)&#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>【练习7.38】有些情况下我们希望提供 cin 作为接受 istream&amp; 参数的构造函数的默认实参，请声明这样的构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(std::istream&amp; is = std::cin)&#123;is &gt;&gt; *<span class="keyword">this</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>此时该函数具有了默认构造函数的作用，因此我们原来声明的默认构造函数<code>Sales_data()=default;</code>应该去掉，否则会引起调用的二义性。</p>
<p>委托构造函数（把自己的一些或全部职责给了其他构造函数）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//非委托构造函数使用对应的实参初始化成员</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s, <span class="type">unsigned</span> cnt, <span class="type">double</span> price):</span><br><span class="line">        <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(cnt), <span class="built_in">revenue</span>(cnt*price)&#123;&#125;</span><br><span class="line">    <span class="comment">//其余构造函数委托给另一个构造函数</span></span><br><span class="line">    <span class="built_in">Sales_data</span>():<span class="built_in">Sales_data</span>(<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s):<span class="built_in">Sales_data</span>(s,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;is):<span class="built_in">Sales_data</span>()&#123;<span class="built_in">read</span>(is,*<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。在<code>Sales_data</code>类中，受委托的构造函数体恰好是空的。假如函数体包含有代码的话，将先执行这些代码，然后控制权才会交还给委托者的函数体。具体参阅配套习题第174页（练习7.41）：</p>
<p><img src="https://bu.dusays.com/2023/03/27/64218b2ed9656.png" alt="17-21dot5.png"></p>
<p>默认构造函数的作用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoDefault</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NoDefault</span>(<span class="type">const</span> std::string&amp;);</span><br><span class="line">    <span class="comment">//还有其他成员，但没有其他构造函数了</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    NoDefault my_mem;</span><br><span class="line">&#125;;</span><br><span class="line">A a; <span class="comment">//错误！不能为A合成构造函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="built_in">B</span>()&#123;&#125; <span class="comment">//错误！b_member没有初始值</span></span><br><span class="line">    NoDefault b_member;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>在实际中，如果定义了其他构造函数，最好也提供一个默认构造函数。</strong></p>
<p>隐式的类类型转换:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string null_book = <span class="string">&quot;9-999-99999-9&quot;</span>;</span><br><span class="line"><span class="comment">//构造一个临时的Sales_data对象</span></span><br><span class="line"><span class="comment">//该对象的units_sold和revenue等于0，bookNo等于null_book</span></span><br><span class="line">item.<span class="built_in">combine</span>(null_book);</span><br></pre></td></tr></table></figure>
<p>只允许一步类类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">item.<span class="built_in">combine</span>(<span class="string">&quot;9-999-99999-9&quot;</span>);</span><br><span class="line"><span class="comment">//错误！这里试图经历两种转换：</span></span><br><span class="line"><span class="comment">//1. 把“9-999-99999-9”转换成string</span></span><br><span class="line"><span class="comment">//2. 再把这个（临时的）string转换成Sales_data</span></span><br></pre></td></tr></table></figure>
<p>下面这三种写法是允许的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">string</span>(<span class="string">&quot;9-999-99999-9&quot;</span>));</span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(<span class="string">&quot;9-999-99999-9&quot;</span>)); <span class="comment">//隐式地转换成string，再显式地转换成Sales_data</span></span><br><span class="line">item.<span class="built_in">combine</span>(cin);</span><br></pre></td></tr></table></figure>
<p>抑制构造函数定义的隐式转换：explicit（清楚、明白的）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">        <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span>:bookNo(s)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(std::istream&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">item.<span class="built_in">combine</span>(null_book); <span class="comment">//错误！string构造函数是explicit的</span></span><br><span class="line">item.<span class="built_in">combine</span>(cin);       <span class="comment">//错误！istream构造函数是explicit的</span></span><br></pre></td></tr></table></figure>
<p><code>explicit</code>关键字只允许出现在类内的构造函数声明处：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误！</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data::Sales_data</span><span class="params">(istream&amp; is)</span></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(is, *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>explicit</code>构造函数只能用于直接初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">item1</span><span class="params">(null_book)</span></span>; <span class="comment">//正确，直接初始化</span></span><br><span class="line">Sales_data item2 = null_book;</span><br><span class="line"><span class="comment">//错误！不能将explicit构造函数用于拷贝形式的初始化过程</span></span><br></pre></td></tr></table></figure>
<p>为转换显式地使用构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确，实参是一个显式构造的Sales_data对象</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(null_book));</span><br><span class="line"><span class="comment">//正确，static_cast可以使用explicit的构造函数</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">static_cast</span>&lt;Sales_data&gt;(cin));</span><br></pre></td></tr></table></figure>
<p>聚合类 <strong>（aggregate class）</strong>：</p>
<ul>
<li>所有成员都是<code>public</code>的</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始值</li>
<li>没有基类，也没有<code>virtual</code>函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">    <span class="type">int</span> ival;</span><br><span class="line">    string s;</span><br><span class="line">&#125;;</span><br><span class="line">Data val1 = &#123;<span class="number">0</span>, <span class="string">&quot;Anna&quot;</span>&#125;; <span class="comment">//可以使用初始值列表</span></span><br></pre></td></tr></table></figure>
<p>字面值常量类：（或称“字面值类”）</p>
<ul>
<li>数据成员都必须是字面值类型</li>
<li>类必须至少含有一个<code>constexpr</code>构造函数</li>
<li>如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的<code>constexpr</code>构造函数</li>
<li>类必须使用析构函数的默认定义，该成员负责销毁类的对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个例子，其具体作用暂时不必关心</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Debug</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="type">bool</span> b=<span class="literal">true</span>)</span>:hw(b), io(b), other(b)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="type">bool</span> h, <span class="type">bool</span> i, <span class="type">bool</span> o)</span>:hw(h),io(i),other(o)&#123;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">any</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> hw||io||other;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_io</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123;io=b;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_hw</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123;hw=b;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_other</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123;hw=b;&#125; <span class="comment">//这里原书可能有误？</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> hw;        <span class="comment">//硬件错误，而非IO错误</span></span><br><span class="line">    <span class="type">bool</span> io;        <span class="comment">//IO错误</span></span><br><span class="line">    <span class="type">bool</span> other;     <span class="comment">//其他错误</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>constexpr</code>构造函数用于生成<code>constexpr</code>对象以及<code>constexpr</code>函数的参数或返回类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Debug <span class="title">io_sub</span><span class="params">(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>)</span></span>; <span class="comment">//调试IO</span></span><br><span class="line"><span class="keyword">if</span>(io_sub.<span class="built_in">any</span>())    <span class="comment">//等价于if(true)</span></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;print appropriate error messages&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Debug <span class="title">prod</span><span class="params">(<span class="literal">false</span>)</span></span>;                <span class="comment">//无调试</span></span><br><span class="line"><span class="keyword">if</span>(prod.<span class="built_in">any</span>())      <span class="comment">//等价于if(false)</span></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;print an error message&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><p>与类本身关联，而不需要与每个对象关联。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span>&#123;amount+=amount*interestRate;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> interestRate;&#125;</span><br><span class="line">    <span class="comment">//static函数不包含this指针，所以不能定义为const函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string owner;</span><br><span class="line">    <span class="type">double</span> amount;</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> interestRate;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">initRate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>静态成员存在于任何对象之外，所有对象共享:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> r;</span><br><span class="line">r = Account::<span class="built_in">rate</span>();</span><br><span class="line">Account ac1;</span><br><span class="line">Account *ac2 = &amp;ac1;</span><br><span class="line">r = ac1.<span class="built_in">rate</span>();</span><br><span class="line">r = ac2-&gt;<span class="built_in">rate</span>(); <span class="comment">//与上一行效果相同</span></span><br></pre></td></tr></table></figure>
<p>可以在类的内部也可以在类的外部定义<strong>静态成员函数</strong>。在外部定义时，不能重复<code>static</code>关键字，<code>static</code>关键字只出现在类内部的声明语句中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Account::rate</span><span class="params">(<span class="type">double</span> newRate)</span></span>&#123;</span><br><span class="line">    interestRate = newRate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>静态数据成员：</strong></p>
<p><img src="https://bu.dusays.com/2023/02/04/63dde8a1d30f3.png" alt="17-22.png"></p>
<p>想要确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放到同一个文件中。</p>
<p>静态成员的类内初始化。通常，类的静态成员不该在类的内部初始化（因为里面仅仅是一个声明）。以下是特殊情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> interestRate;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> period = <span class="number">30</span>; <span class="comment">//period是常量表达式，可以用字面值替换</span></span><br><span class="line">    <span class="type">double</span> daily_tbl[period];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了：</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> Account::period;</span><br><span class="line"><span class="comment">//即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员</span></span><br></pre></td></tr></table></figure>
<p>静态成员能用于某些场景，而普通成员不能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Bar mem1; <span class="comment">//正确：静态成员可以是不完全类型</span></span><br><span class="line">    Bar *mem2;       <span class="comment">//正确</span></span><br><span class="line">    Bar mem3;        <span class="comment">//错误！数据成员必须是完全类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以使用静态成员作为默认实参，因为它本身不是对象的一部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//bkground表示一个在类中稍后定义的静态成员</span></span><br><span class="line">    <span class="function">Screen&amp; <span class="title">clear</span><span class="params">(<span class="type">char</span> = bkground)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> bkground;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Sales-data-综合（实例）"><a href="#Sales-data-综合（实例）" class="headerlink" title="Sales_data 综合（实例）"></a>Sales_data 综合（实例）</h2><p>目前，我个人更倾向于<code>char* p;</code>的写法。</p>
<p>关于这之中可能的争议：</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/6990726/correct-way-of-declaring-pointer-variables-in-c-c">https://stackoverflow.com/questions/6990726/correct-way-of-declaring-pointer-variables-in-c-c</a></p>
<p><strong>注意：以下程序尚未经过仔细的测试。</strong>（进一步的测试请转到【练习8.7】）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sales_data.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp; lhs, <span class="type">const</span> Sales_data&amp; rhs)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> std::istream&amp; <span class="title">read</span><span class="params">(std::istream&amp; is, Sales_data&amp; item)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">friend</span> std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp; os, <span class="type">const</span> Sales_data&amp; item)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">Sales_data</span>(<span class="type">const</span> std::string&amp; s):<span class="built_in">bookNo</span>(s)&#123;&#125;</span><br><span class="line">	<span class="built_in">Sales_data</span>(<span class="type">const</span> std::string&amp; s,<span class="type">unsigned</span> n,<span class="type">double</span> p):<span class="built_in">bookNo</span>(s),<span class="built_in">units_sold</span>(n),<span class="built_in">revenue</span>(p*n)&#123;&#125;</span><br><span class="line">	<span class="built_in">Sales_data</span>(std::istream&amp; is);</span><br><span class="line">	</span><br><span class="line">	<span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">	<span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp; item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> units_sold ? revenue/units_sold : <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">	std::string bookNo;</span><br><span class="line">	<span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非成员接口函数：友元函数</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp; lhs, <span class="type">const</span> Sales_data&amp; rhs)</span></span>;</span><br><span class="line"><span class="function">std::istream&amp; <span class="title">read</span><span class="params">(std::istream&amp; is, Sales_data&amp; item)</span></span>;</span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp; os, <span class="type">const</span> Sales_data&amp; item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sales_data_Implementation.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sales_data.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Sales_data::<span class="built_in">Sales_data</span>(std::istream&amp; is)&#123;</span><br><span class="line">	<span class="built_in">read</span>(is,*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data&amp; <span class="title">Sales_data::combine</span><span class="params">(<span class="type">const</span> Sales_data&amp; item)</span></span>&#123;</span><br><span class="line">	units_sold += item.units_sold;</span><br><span class="line">	revenue += item.revenue;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp; lhs, <span class="type">const</span> Sales_data&amp; rhs)</span></span>&#123;</span><br><span class="line">	Sales_data sum = lhs;</span><br><span class="line">	sum.<span class="built_in">combine</span>(rhs);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::istream&amp; <span class="title">read</span><span class="params">(std::istream&amp; is, Sales_data&amp; item)</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> price = <span class="number">0</span>;</span><br><span class="line">	is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">	item.revenue = price*item.units_sold;</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp; os, <span class="type">const</span> Sales_data&amp; item)</span></span>&#123;</span><br><span class="line">	os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">       &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">avg_price</span>()&lt;&lt;std::endl;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sales_data_Main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sales_data.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string name = <span class="string">&quot;BOOKONE&quot;</span>;</span><br><span class="line">	<span class="function">Sales_data <span class="title">book1</span><span class="params">(name,<span class="number">18</span>,<span class="number">2.6</span>)</span></span>;</span><br><span class="line">	<span class="function">Sales_data <span class="title">book2</span><span class="params">(cin)</span></span>;</span><br><span class="line">	<span class="built_in">print</span>(cout,book1);</span><br><span class="line">	<span class="built_in">print</span>(cout,book2);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入样例：</span></span><br><span class="line"><span class="comment">BOOKTWO</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">5.5</span></span><br><span class="line"><span class="comment">期望输出：</span></span><br><span class="line"><span class="comment">BOOKONE 18 46.8 2.6</span></span><br><span class="line"><span class="comment">BOOKTWO 10 55 5.5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><p><img src="https://bu.dusays.com/2023/03/13/640ec200609a3.png" alt="17-23.png"></p>
<p>关于<strong>宽字符</strong>：参见《C++ primer》278 页。</p>
<p>类型<code>ifstream</code>和<code>istringstream</code>都继承自<code>istream</code>。因此，可以像使用<code>istream</code>对象一样来使用<code>ifstream</code>和<code>istringstream</code>对象。例如，可以对<code>ifstream</code>或<code>istringstream</code>对象调用<code>getline</code>，也可以用<code>&gt;&gt;</code>从一个<code>ifstream</code>或<code>istringstream</code>对象中读取数据。类似的，类型<code>ofstream</code>和<code>ostringstream</code>都继承自<code>ostream</code>。</p>
<p>IO对象无拷贝或赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ofstream out1, out2;</span><br><span class="line">out1 = out2;               <span class="comment">//错误！不能对流对象赋值</span></span><br><span class="line"><span class="function">ofstream <span class="title">print</span><span class="params">(ofstream)</span></span>;  <span class="comment">//错误！不能将形参或返回类型设为流类型</span></span><br><span class="line">out2 = <span class="built_in">print</span>(out2);        <span class="comment">//错误！不能拷贝流对象</span></span><br></pre></td></tr></table></figure>
<p>读写一个 IO 对象会改变其状态，因此传递和返回的引用不能是<code>const</code>的。</p>
<p><img src="https://bu.dusays.com/2023/03/13/640edc3ca07fe.png" alt="17-24.png"></p>
<p>查询流的状态：</p>
<p>IO 库定义了一个与机器无关的<code>iostate</code>类型，它提供了表达流状态的完整功能。这个类型应作为一个位集合来使用。IO 库定义了 4 个<code>iostate</code>类型的<code>constexpr</code>值，表示特定的位模式。这些值用来表示特定类型的 IO 条件，可以与位运算符一起使用来一次性检测或设置多个标志位。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不同机器里面可能不一样 (?)</span></span><br><span class="line">goodbit = <span class="number">0x0</span></span><br><span class="line">eofbit = <span class="number">0x1</span></span><br><span class="line">failbit = <span class="number">0x2</span></span><br><span class="line">badbit = <span class="number">0x4</span></span><br></pre></td></tr></table></figure>
<p><code>badbit</code>表示系统级错误，如不可恢复的读写错误。通常情况下，一旦<code>badbit</code>被置位，流就无法再使用了。在发生可恢复错误后，<code>failbit</code>被置位，如期望读取数值却读出一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。如果到达文件结束位置，<code>eofbit</code>和<code>failbit</code>都会被置位。<code>goodbit</code>的值为 0 ，表示流未发生错误。如果<code>badbit</code>、<code>failbit</code>和<code>eofbit</code>任一个被置位，则检测流状态的条件会失败。</p>
<p>标准库还定义了一组函数来查询这些标志位的状态。操作<code>good</code>在所有错误位均未置位的情况下返回 true，而<code>bad</code>、<code>fail</code>和<code>eof</code>则在对应错误位被置位时返回 true。此外，在<code>badbit</code>被置位时，<code>fail</code>也会返回true 。这意味着，使用<code>good</code>或<code>fail</code>是确定流的总体状态的正确方法。实际上，我们将流当作条件使用的代码就等价于<code>!fail()</code>。而<code>eof</code>和<code>bad</code>操作只能表示特定的错误。</p>
<p>管理条件状态：</p>
<p>流对象的<code>rdstate</code>成员返回一个<code>iostate</code>值，对应流的当前状态。<code>setstate</code>操作将给定条件位置位，表示发生了对应错误。<code>clear</code>成员是一个重载的成员：它有一个不接受参数的版本，而另一个版本接受一个<code>iostate</code>类型的参数。</p>
<p><code>clear</code>不接受参数的版本清除（复位）所有错误标志位。执行<code>clear()</code>后，调用<code>good</code>会返回 true 。我们可以这样使用这些成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> old_state = cin.<span class="built_in">rdstate</span>(); <span class="comment">//记住 cin 的当前状态</span></span><br><span class="line">cin.<span class="built_in">clear</span>();                    <span class="comment">//使 cin 有效</span></span><br><span class="line"><span class="built_in">process_input</span>(cin);             <span class="comment">//使用 cin</span></span><br><span class="line">cin.<span class="built_in">setstate</span>(old_state);        <span class="comment">//将 cin 置为原始状态</span></span><br></pre></td></tr></table></figure>
<p>带参数的<code>clear</code>版本接受一个<code>iostate</code>值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复位 failbit 和 badbit ，保持其他标志位不变</span></span><br><span class="line">cin.<span class="built_in">clear</span>(cin.<span class="built_in">rdstate</span>() &amp; ~cin.failbit &amp; ~cin.badbit);</span><br><span class="line"><span class="comment">/*-------------位运算，比较好理解：----------</span></span><br><span class="line"><span class="comment">这里 0 代表无错，1 有错。failbit 中的 1 取反后</span></span><br><span class="line"><span class="comment">变成 0，任何一个数(0/1) &amp; 0 都变成 0，完成置位。</span></span><br><span class="line"><span class="comment">同时 failbit 中的 0 取反后变成 1，任何一个数(0/1)</span></span><br><span class="line"><span class="comment">&amp; 1 都不变。</span></span><br><span class="line"><span class="comment">badbit 同理。</span></span><br><span class="line"><span class="comment">------------------------------------------*/</span></span><br></pre></td></tr></table></figure>
<p>【练习8.1】编写函数，接受一个 istream&amp; 参数，返回值类型也是 istream&amp; 。此函数须从给定流中读取数据，直到遇到 eof 停止。它将读取的数据打印在标准输出上。完成这些操作后，在返回流之前，对流进行复位，使其处于有效状态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">istream&amp; <span class="title">f</span><span class="params">(istream&amp; in)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">while</span>(in&gt;&gt;v, !in.<span class="built_in">eof</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(in.<span class="built_in">bad</span>()) <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;io-stream error&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(in.<span class="built_in">fail</span>())&#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Data error, please try again: &quot;</span> &lt;&lt; endl;</span><br><span class="line">            in.<span class="built_in">clear</span>();</span><br><span class="line">            in.<span class="built_in">ignore</span>(<span class="number">100</span>, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    in.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please enter some integers and press Ctrl+Z to end: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">f</span>(cin);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题（未解决）：某些配置无法处理中文，甚至会导致程序的错误</span></span><br></pre></td></tr></table></figure>
<p><strong>关于上例代码的一些解释（注意：整理自网络，不能严格保证其正确性）</strong>：</p>
<ul>
<li>在函数<code>f</code>中，<code>in.ignore(100, &#39;\n&#39;)</code>的作用是忽略输入流中的一些字符，直到遇到换行符为止，或者忽略了 100 个字符。这里的换行符<code>&#39;\n&#39;</code>是因为在输入整数时，用户可能会在输入后按下回车键，导致换行符被输入流中。通过忽略换行符，可以清除输入流中的垃圾数据，使得下一个整数输入操作能够得到正确的输入。忽略字符的操作是在输入流中移动指针，使得下一次读取操作可以从正确的位置开始。</li>
<li>需要注意的是，如果忽略了指定的最大数量 n 仍然没有遇到终止字符 c，则会设置输入流的<code>failbit</code>标志，表示输入流状态错误。</li>
<li>它的一个常用功能就是用来清除以回车结束的输入缓冲区的内容，消除上一次输入对下一次输入的影响。例如，<code>cin.ignore(1024, &#39;\n&#39;)</code>，通常把第一个参数设置得足够大，这样是为了只有第二个参数 ‘\n’ 起作用。所以这一句就是把回车（包括回车）之前的所有字符从输入缓冲流中清除出去。</li>
<li>如果默认不给参数的话，默认参数为<code>cin.ignore(1, EOF)</code>，即把EOF前的1个字符清掉，没有遇到EOF就清掉一个字符然后结束。</li>
<li><code>in.clear()</code>成员函数用于清除输入流的错误标志，但是它并不会清除输入流中的垃圾数据。</li>
</ul>
<p><img src="https://bu.dusays.com/2023/03/28/64225c3108ab5.png" alt="17-25.png" title="上例代码测试结果"></p>
<p>管理输出缓冲：</p>
<p><img src="https://bu.dusays.com/2023/03/28/64225ef3e4a4c.png" alt="17-26.png" title="缓冲刷新的原因"></p>
<p>刷新输出缓冲区：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;hi!&quot;</span> &lt;&lt; endl;  <span class="comment">//输出 hi! 和一个换行，然后刷新缓冲区</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hi!&quot;</span> &lt;&lt; flush; <span class="comment">//输出 hi! ，然后刷新缓冲区</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hi!&quot;</span> &lt;&lt; ends;  <span class="comment">//输出 hi! 和一个空字符，然后刷新缓冲区</span></span><br></pre></td></tr></table></figure>
<p><code>unitbuf</code>操纵符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; unitbuf;    <span class="comment">//所有输出操作后都会立即刷新缓冲区</span></span><br><span class="line">cout &lt;&lt; nounitbuf;  <span class="comment">//回到正常的缓冲方式</span></span><br></pre></td></tr></table></figure>
<p><strong>警告：如果程序崩溃，输出缓冲区不会被刷新。</strong></p>
<p>关联输入和输出流：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; ival;   <span class="comment">//会导致 cout 的缓冲区被刷新</span></span><br></pre></td></tr></table></figure>
<p><code>tie</code>有两个重载的版本：一个版本不带参数，返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针。<code>tie</code>的第二个版本接受一个指向<code>ostream</code>的指针，将自己关联到此<code>ostream</code>。即，<code>x.tie(&amp;o)</code>将流<code>x</code>关联到输出流<code>o</code>。</p>
<p>既可以将一个<code>istream</code>对象关联到另一个<code>ostream</code>，也可以将一个<code>ostream</code>关联到另一个<code>ostream</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">tie</span>(&amp;cout);  <span class="comment">//仅作展示：标准库将cin和cout关联在一起</span></span><br><span class="line"><span class="comment">// old_tie指向当前关联到cin的流（如果有的话）</span></span><br><span class="line">ostream* old_tie = cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>); <span class="comment">// cin 不再与其他流关联</span></span><br><span class="line"><span class="comment">// 将cin和cerr关联：not a good idea，仅作展示</span></span><br><span class="line">cin.<span class="built_in">tie</span>(&amp;cerr);  <span class="comment">//读取cin会刷新cerr，而不是cout</span></span><br><span class="line">cin.<span class="built_in">tie</span>(old_tie);  <span class="comment">//重建cin和cout的正常关联</span></span><br></pre></td></tr></table></figure>
<p>每个流同时最多关联到一个流，但多个流可以同时关联到同一个<code>ostream</code>。</p>
<h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><p><img src="https://bu.dusays.com/2023/04/01/6427ff6356b4f.png" alt="17-27.png" title="fstream 特有的操作"></p>
<p>使用文件流对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>; <span class="comment">//构造一个ifstream并打开给定文件</span></span><br><span class="line">ofstream out;       <span class="comment">//输出文件流未关联到任何文件</span></span><br></pre></td></tr></table></figure>
<p>在新 C++ 标准中，文件名既可以是库类型 string 对象，也可以是 C 风格字符数组。旧版本的标准库只允许 C 风格字符数组。</p>
<p>用<code>fstream</code>代替<code>iostream&amp;</code>：在要求使用基类型对象的地方，可以用继承类型的对象来替代。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本例中，假定输入和输出文件的名字是通过传给main的参数来指定的</span></span><br><span class="line"><span class="function">ifstream <span class="title">input</span><span class="params">(argv[<span class="number">1</span>])</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">output</span><span class="params">(argv[<span class="number">2</span>])</span></span>;</span><br><span class="line">Sales_data total;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">read</span>(input, total))&#123; <span class="comment">//读取第一条销售记录</span></span><br><span class="line">    Sales_data trans;   <span class="comment">//保存下一条销售记录的变量</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">read</span>(input, trans))&#123;</span><br><span class="line">        <span class="keyword">if</span>(total.<span class="built_in">isbn</span>()==trans.<span class="built_in">isbn</span>())</span><br><span class="line">            total.<span class="built_in">combine</span>(trans);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">print</span>(output, total) &lt;&lt; endl;</span><br><span class="line">            total = trans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(output, total) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;No data ?!&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，重要的是对<code>read</code>和<code>print</code>的调用。虽然两个函数定义时指定的形参分别是<code>istream&amp;</code>和<code>ostream&amp;</code>，但我们可以向它们传递<code>fstream</code>对象。</p>
<p>成员函数<code>open</code>和<code>close</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>; <span class="comment">//构造一个ifstream并打开给定文件</span></span><br><span class="line">ofstream out;       <span class="comment">//输出文件流未关联到任何文件</span></span><br><span class="line">out.<span class="built_in">open</span>(ifile + <span class="string">&quot;.copy&quot;</span>);  <span class="comment">//打开指定文件</span></span><br><span class="line"><span class="keyword">if</span>(out)&#123;            <span class="comment">//检查open是否成功</span></span><br><span class="line">    <span class="comment">/*---*/</span></span><br><span class="line">&#125;</span><br><span class="line">in.<span class="built_in">close</span>();         <span class="comment">//关闭文件</span></span><br><span class="line">in.<span class="built_in">open</span>(ifile + <span class="string">&quot;2&quot;</span>);  <span class="comment">//打开另一个文件</span></span><br></pre></td></tr></table></figure>
<p>如果调用<code>open</code>失败，<code>failbit</code>会被置位。如果<code>open</code>成功，流的状态<code>good()</code>会为<code>true</code>。</p>
<p>自动构造和析构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main接受一个要处理的文件列表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = argv+<span class="number">1</span>; p != argv+argc; p++)&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">input</span><span class="params">(*p)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(input)&#123;  <span class="comment">//如果文件打开成功，“处理”此文件</span></span><br><span class="line">        <span class="built_in">process</span>(input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;couldn&#x27;t open: &quot;</span> + <span class="built_in">string</span>(*p);</span><br><span class="line">&#125; <span class="comment">//每个循环步input都会离开作用域，因此会被销毁</span></span><br></pre></td></tr></table></figure>
<p><strong>当一个<code>fstream</code>对象离开其作用域时，与之关联的文件会自动关闭。</strong> 即：当一个<code>fstream</code>对象被销毁时，<code>close</code>会自动被调用。</p>
<p>【练习8.4】 编写函数，以读模式打开一个文件，将其内容读入到一个string的vector中，将每一行作为一个独立的元素存于vector中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;      <span class="comment">// 路径中最好不要有中文。</span></span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;D:\\c++code\\exercise8-4\\data.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!in)&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;couldn&#x27;t open file: data.txt&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string line;</span><br><span class="line">    vector&lt;string&gt; words;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(in, line))&#123;</span><br><span class="line">        words.<span class="built_in">push_back</span>(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = words.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(it!=words.<span class="built_in">end</span>())&#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt;endl;</span><br><span class="line">        ++it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//data.txt</span><br><span class="line">tianshangdetaiyang</span><br><span class="line">yueliangyigeyang</span><br><span class="line">yiduoyejuhua</span><br><span class="line">zhengpiaoliang</span><br><span class="line">nidemoyang</span><br><span class="line">songniyiduoshan/san chahua</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//输出结果</span><br><span class="line">tianshangdetaiyang</span><br><span class="line">yueliangyigeyang</span><br><span class="line">yiduoyejuhua</span><br><span class="line">zhengpiaoliang</span><br><span class="line">nidemoyang</span><br><span class="line">songniyiduoshan/san chahua</span><br></pre></td></tr></table></figure>
<p>【练习8.5】重写上面的程序，将每个单词作为一个独立的元素进行存储。</p>
<p>【解答】将<code>while(getline(in, line))</code>改为<code>while(in &gt;&gt; line)</code>即可。</p>
<p>文件模式：</p>
<p><img src="https://bu.dusays.com/2023/04/02/642936e10ad75.png" alt="17-28.png"></p>
<p><img src="https://bu.dusays.com/2023/04/02/642938a965441.png" alt="17-29.png" title="指定文件模式的限制"></p>
<p>以<code>out</code>模式打开文件会丢弃已有数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在这几条语句中，file1都被截断</span></span><br><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;file1&quot;</span>)</span></span>; <span class="comment">//隐含以输出模式打开文件并截断文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">out2</span><span class="params">(<span class="string">&quot;file1&quot;</span>, ofstream::out)</span></span>;  <span class="comment">//隐含地截断文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">out3</span><span class="params">(<span class="string">&quot;file1&quot;</span>, ofstream::out | ofstream::trunc)</span></span>;</span><br><span class="line"><span class="comment">//为了保留文件内容，我们必须显式指定app模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">app</span><span class="params">(<span class="string">&quot;file2&quot;</span>, ofstream::app)</span></span>; <span class="comment">//隐含为输出模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">app2</span><span class="params">(<span class="string">&quot;file2&quot;</span>, ofstream::out | ofstream::app)</span></span>;</span><br></pre></td></tr></table></figure>
<p>每次调用<code>open</code>时都会确定文件模式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ofstream out; <span class="comment">//未指定文件打开模式</span></span><br><span class="line">out.<span class="built_in">open</span>(<span class="string">&quot;scratchpad&quot;</span>); <span class="comment">//模式隐含设置为输出和截断</span></span><br><span class="line">out.<span class="built_in">close</span>();</span><br><span class="line">out.<span class="built_in">open</span>(<span class="string">&quot;previous&quot;</span>, ofstream::app); <span class="comment">//模式为输出和追加</span></span><br><span class="line">out.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>
<p>【练习8.7】修改上一节的书店程序，将结果保存到一个文件中。将输出文件名作为第二个参数传递给 main 函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 8_7main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Sales_data.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Please give the input and output file names&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(argv[<span class="number">1</span>])</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!in)&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Unable to open the input file&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(argv[<span class="number">2</span>])</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!out)&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Unable to open the output file&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Sales_data total;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">read</span>(in, total))&#123; <span class="comment">//读取第一条销售记录</span></span><br><span class="line">        Sales_data trans;   <span class="comment">//保存下一条销售记录的变量</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">read</span>(in, trans))&#123;</span><br><span class="line">            <span class="keyword">if</span>(total.<span class="built_in">isbn</span>()==trans.<span class="built_in">isbn</span>())</span><br><span class="line">                total.<span class="built_in">combine</span>(trans);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">print</span>(out, total) &lt;&lt; endl;</span><br><span class="line">                total = trans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(out, total) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;No data&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件 8_7file_in.txt 内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">war&amp;peace 2 8.8</span><br><span class="line">war&amp;peace 1 9</span><br><span class="line">taoteching 3 3.3</span><br><span class="line">taoteching 6 9</span><br><span class="line">Pride&amp;Prejudice 2 89.64</span><br><span class="line">hewhochangedchina 1926 0.817</span><br></pre></td></tr></table></figure>
<p>创建 8_7file_out.txt 文件，初始为空。此外还有之前提到的文件 Sales_data.h 和 Sales_data_Implementation.cpp ，将它们放至同一个文件夹中。</p>
<p>打开 PowerShell ，更改路径（以博主的机器为例）：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> D:\c++code\exercise8<span class="literal">-7</span></span><br></pre></td></tr></table></figure>
<p>键入以下命令执行分离式编译：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ <span class="number">8</span>_7main.cpp Sales_data_Implementation.cpp <span class="literal">-o</span> <span class="number">8</span>_7prog</span><br></pre></td></tr></table></figure>
<p>键入命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\<span class="number">8</span>_7prog.exe <span class="number">8</span>_7file_in.txt <span class="number">8</span>_7file_out.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://bu.dusays.com/2023/04/02/64296b4f10068.png" alt="17-30.png"></p>
<p>打开 8_7file_out.txt ，发现输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">war&amp;peace 3 26.6 8.86667</span><br><span class="line"></span><br><span class="line">taoteching 9 63.9 7.1</span><br><span class="line"></span><br><span class="line">Pride&amp;Prejudice 2 179.28 89.64</span><br><span class="line"></span><br><span class="line">hewhochangedchina 1926 1573.54 0.817</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果键入：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\<span class="number">8</span>_7prog.exe <span class="number">8</span>_7file_in.txt <span class="number">8</span>_7file_out.txt hana.txt</span><br></pre></td></tr></table></figure>
<p>则 powershell 会显示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Please give the input and output file names</span><br></pre></td></tr></table></figure>
<h2 id="string-流"><a href="#string-流" class="headerlink" title="string 流"></a>string 流</h2><p><img src="https://bu.dusays.com/2023/04/03/642a3f53271cf.png" alt="17-31.png"></p>
<p>使用<code>istringstream</code>：</p>
<p>考虑这样的例子：有一个文件，列出了一些人名和他们的电话号码。某些人只有一个号码，而另一些则有多个。输入文件格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">morgan 2015552368 8625550123</span><br><span class="line">drew 9735550130</span><br><span class="line">lee 6095550132 2015550175 8005550000</span><br></pre></td></tr></table></figure>
<p>核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PersonInfo</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    vector&lt;string&gt; phones;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// --------------------</span></span><br><span class="line">string line, word;</span><br><span class="line">vector&lt;PersonInfo&gt; people;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(cin, line))&#123;</span><br><span class="line">    PersonInfo info;</span><br><span class="line">    <span class="function">istringstream <span class="title">record</span><span class="params">(line)</span></span>;</span><br><span class="line">    record &gt;&gt; info.name;</span><br><span class="line">    <span class="keyword">while</span>(record &gt;&gt; word)</span><br><span class="line">        info.phones.<span class="built_in">push_back</span>(word);</span><br><span class="line">    people.<span class="built_in">push_back</span>(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【练习8.9】 使用 练习8.1 中编写的函数打印一个<code>istringstream</code>对象的内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">istream&amp; <span class="title">f</span><span class="params">(istream&amp; in)</span></span>&#123;</span><br><span class="line">    string v;</span><br><span class="line">    <span class="keyword">while</span>(in&gt;&gt;v, !in.<span class="built_in">eof</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(in.<span class="built_in">bad</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;io-stream error&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(in.<span class="built_in">fail</span>())&#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Data error, please try again: &quot;</span> &lt;&lt; endl;</span><br><span class="line">            in.<span class="built_in">clear</span>();</span><br><span class="line">            in.<span class="built_in">ignore</span>(<span class="number">1000</span>, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    in.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ostringstream msg;</span><br><span class="line">    msg &lt;&lt; <span class="string">&quot;C++ Primer 5th Edition&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">istringstream <span class="title">in</span><span class="params">(msg.str())</span></span>;</span><br><span class="line">    <span class="built_in">f</span>(in);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C++</span><br><span class="line">Primer</span><br><span class="line">5th</span><br><span class="line">Edition</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重复使用字符串流时，每次都用调用<code>clear</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">record.<span class="built_in">clear</span>(); <span class="comment">// record 是 istringstream 对象</span></span><br></pre></td></tr></table></figure>
<p>使用<code>ostringstream</code>：</p>
<p>考虑情景：我们需要验证并改变电话号码的格式。对于无效的电话号码，需要打印错误信息。</p>
<p>核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ostringstream os;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;entry : people)&#123; <span class="comment">//对people中的每一项</span></span><br><span class="line">    ostringstream formatted, badNums;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;nums : entry.phones)&#123;  <span class="comment">//对每个数</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">valid</span>(nums))&#123;</span><br><span class="line">            badNums &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            formatted &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; format(nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(badNums.<span class="built_in">str</span>().<span class="built_in">empty</span>())</span><br><span class="line">        os &lt;&lt; entry.name &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">           &lt;&lt; formatted.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;input error: &quot;</span> &lt;&lt; entry.name</span><br><span class="line">             &lt;&lt; <span class="string">&quot; invalid number(s) &quot;</span> &lt;&lt; badNums.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; os.<span class="built_in">str</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h2><p><img src="https://bu.dusays.com/2023/04/04/642b9722be985.png" alt="17-32.png"></p>
<p><code>forward_list</code>和<code>array</code>是新 C++ 标准增加的类型。</p>
<p><code>forward_list</code>没有<code>size</code>操作，因为保存或计算其大小就会比手写链表多出额外的开销。<strong>对其他容器而言，<code>size</code>保证是一个快速的常量时间的操作。</strong></p>
<p><strong>NOTE ：</strong> 新标准库的容器比旧版本快得多。现代 C++ 程序应该使用标准库容器，而不是更原始的数据结构，如内置数组。</p>
<p><img src="https://bu.dusays.com/2023/04/04/642b9fd03d97a.png" alt="17-33.png" title="选择容器的基本原则"></p>
<h2 id="容器库概览"><a href="#容器库概览" class="headerlink" title="容器库概览"></a>容器库概览</h2><p>一种合法的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; lines; <span class="comment">// vector 的 vector</span></span><br></pre></td></tr></table></figure>
<p>较旧的编译器可能需要这样写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt; &gt; lines;</span><br></pre></td></tr></table></figure>
<p>虽然可以在容器中保存几乎任何类型，但某些容器操作对元素类型有自己的特殊要求。我们可以定义某类容器（即便它的类型不支持特定操作），但这种情况下，就只能使用那些无特殊要求的容器操作。</p>
<p>例如，顺序容器构造函数的一个版本接受容器大小参数，它使用了元素类型的默认构造函数。但某些类没有默认构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假定 noDefault 是一个没有默认构造函数的类型</span></span><br><span class="line"><span class="function">vector&lt;noDefault&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, init)</span></span>;  <span class="comment">//正确。提供了元素初始化器</span></span><br><span class="line"><span class="function">vector&lt;noDefault&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>;        <span class="comment">//错误！必须提供一个元素初始化器</span></span><br></pre></td></tr></table></figure>
<p>一个更直观的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(std::string b)&#123;a = b;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getStr</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">aObj</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;A&gt; <span class="title">objA</span><span class="params">(<span class="number">5</span>, aObj)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> it = objA.<span class="built_in">cbegin</span>();</span><br><span class="line">    <span class="keyword">for</span>(; it!=objA.<span class="built_in">cend</span>(); ++it)&#123;</span><br><span class="line">        std::cout &lt;&lt; (*it).<span class="built_in">getStr</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*------- 输出结果 --------</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">-------------------------*/</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，若第 13 行改为<code>std::string aObj(&quot;hello&quot;);</code>也是可以的，这里存在隐式转换。</p>
<p>若第 14 行写成<code>std::vector&lt;A&gt; objA(5);</code>，就会报错。</p>
<p><img src="https://bu.dusays.com/2023/04/06/642e8bd490340.png" alt="17-34.png" title="容器操作"></p>
<p><strong><code>forward_list</code>迭代器不支持递减运算符<code>--</code>。</strong></p>
<p>迭代器范围（iterator range）： <code>[begin, end)</code></p>
<p>【练习9.5】 题目描述没什么看头。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ivecit = vector&lt;<span class="type">int</span>&gt;::iterator;</span><br><span class="line"></span><br><span class="line"><span class="function">ivecit <span class="title">search_vec</span><span class="params">(ivecit beg, ivecit end, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; beg!=end; beg++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*beg==val) <span class="keyword">return</span> beg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ilist = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> , <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">search_vec</span>(ilist.<span class="built_in">begin</span>(), ilist.<span class="built_in">end</span>(), <span class="number">3</span>)-ilist.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">search_vec</span>(ilist.<span class="built_in">begin</span>(), ilist.<span class="built_in">end</span>(), <span class="number">8</span>)-ilist.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">7</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过类型别名，可以在不了解容器中元素类型的情况下使用它。如果需要元素类型，可以使用容器的<code>value_type</code>。如果需要元素类型的一个引用，可以使用<code>reference</code>或<code>const_reference</code>。</p>
<p>为了使用这些类型，必须显式地使用其类名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt;::iterator iter;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::difference_type count;</span><br></pre></td></tr></table></figure>
<p><code>begin</code>和<code>end</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; a = &#123;<span class="string">&quot;Milton&quot;</span>, <span class="string">&quot;Shakespeare&quot;</span>, <span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it1 = a.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> it2 = a.<span class="built_in">rbegin</span>(); <span class="comment">// list&lt;string&gt;::reverse_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = a.<span class="built_in">cbegin</span>();</span><br><span class="line"><span class="keyword">auto</span> it4 = a.<span class="built_in">crbegin</span>(); <span class="comment">// list&lt;string&gt;::const_reverse_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it7 = a.<span class="built_in">begin</span>(); <span class="comment">// 仅当 a 是 const 时，it7 是 const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it8 = a.<span class="built_in">cbegin</span>(); <span class="comment">// it8 是 const_iterator</span></span><br></pre></td></tr></table></figure>
<p><strong>容器定义和初始化：</strong></p>
<p><img src="https://bu.dusays.com/2023/04/11/64355b082b233.png" alt="17-35.png"></p>
<p>一个容器初始化为另一个容器的拷贝时，容器类型和元素类型必须相同。不过，当传迭代器参数来拷贝一个范围时（该方法不适用于array），无此要求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; authors = &#123;<span class="string">&quot;Milton&quot;</span>, <span class="string">&quot;Shakespeare&quot;</span>, <span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; articles = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">list2</span><span class="params">(authors)</span></span>;      <span class="comment">//正确。类型匹配</span></span><br><span class="line"><span class="function">deque&lt;string&gt; <span class="title">authList</span><span class="params">(authors)</span></span>;  <span class="comment">//错误！容器类型不匹配</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">words</span><span class="params">(articles)</span></span>;   <span class="comment">//错误！</span></span><br><span class="line"><span class="comment">//正确。可以将const char* 转换为 string</span></span><br><span class="line"><span class="function">forward_list&lt;string&gt; <span class="title">words</span><span class="params">(articles.begin(), articles.end())</span></span>;</span><br><span class="line"><span class="function">deque&lt;string&gt; <span class="title">authList</span><span class="params">(authors.begin(), it)</span></span>;  <span class="comment">//it是一个迭代器，指向authors的一个元素</span></span><br></pre></td></tr></table></figure>
<p>与顺序容器大小相关的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>, <span class="number">-1</span>)</span></span>; <span class="comment">//10个int元素，每个都初始化为-1</span></span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">slis</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;hi!&quot;</span>)</span></span>; <span class="comment">//10个string，每个都初始化为 &quot;hi!&quot;</span></span><br><span class="line"><span class="function">forward_list&lt;<span class="type">int</span>&gt; <span class="title">ifli</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//10个元素，每个都初始化为0</span></span><br><span class="line"><span class="function">deque&lt;string&gt; <span class="title">sdeq</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">//10个元素，每个都是空string</span></span><br></pre></td></tr></table></figure>
<p>如果元素类型是内置类型或是具有默认构造函数的类类型，可以只为构造函数提供一个容器大小参数。</p>
<p>只有顺序容器的构造函数才接受大小参数，关联容器并不支持。</p>
<p>标准库 array 具有固定大小：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>,5&gt; ia1; <span class="comment">//5个默认初始化的 int</span></span><br><span class="line">array&lt;<span class="type">int</span>,5&gt; ia2 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">array&lt;<span class="type">int</span>,5&gt; ia3 = &#123;<span class="number">42</span>&#125;; <span class="comment">//ia3[0]为42，剩余元素为0</span></span><br><span class="line"><span class="comment">//内置数组类型不能进行拷贝，或对象赋值操作。但array无此限制</span></span><br><span class="line">array&lt;<span class="type">int</span>,5&gt; digits = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">array&lt;<span class="type">int</span>,5&gt; copy = digits; <span class="comment">//正确。只要数组类型匹配即合法</span></span><br></pre></td></tr></table></figure>
<p>array 允许赋值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>,10&gt; a1 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">array&lt;<span class="type">int</span>,10&gt; a2 = &#123;<span class="number">0</span>&#125;;      <span class="comment">//所有元素值均为 0</span></span><br><span class="line">a1 = a2;                       <span class="comment">//替换a1中的元素</span></span><br><span class="line">a2 = &#123;<span class="number">0</span>&#125;;    <span class="comment">//错误！不能将一个花括号列表赋予数组</span></span><br></pre></td></tr></table></figure>
<p><img src="https://bu.dusays.com/2023/04/12/64362b258121c.png" alt="17-36.png" title="容器赋值运算"></p>
<p>使用<code>assign</code>（仅顺序容器）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; names;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; oldstyle;</span><br><span class="line">names = oldstyle;  <span class="comment">//错误！</span></span><br><span class="line">names.<span class="built_in">assign</span>(oldstyle.<span class="built_in">cbegin</span>(), oldstyle.<span class="built_in">cend</span>());</span><br><span class="line"><span class="comment">//正确。可以将 const char* 转换为 string</span></span><br></pre></td></tr></table></figure>
<p><code>assign</code>的第二个版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等价于 slist1.clear();</span></span><br><span class="line"><span class="comment">//后跟 slist1.insert(slist1.begin(), 10, &quot;Hiya!&quot;);</span></span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">slist1</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">//1个元素，为空string</span></span><br><span class="line">slist1.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="string">&quot;Hiya!&quot;</span>); <span class="comment">//10个元素，每个都是 &quot;Hiya!&quot;</span></span><br></pre></td></tr></table></figure>
<p>使用<code>swap</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec2</span><span class="params">(<span class="number">24</span>)</span></span>;</span><br><span class="line"><span class="built_in">swap</span>(svec1, svec2); <span class="comment">//调用完后svec1包含24个string元素</span></span><br></pre></td></tr></table></figure>
<p><strong>除 array 外，swap 不对任何元素进行拷贝、删除、插入操作，因此是常数时间开销。</strong></p>
<p>元素不会被移动的事实意味着，除<code>string</code>外，指向容器的迭代器、引用和指针在<code>swap</code>操作之后都不会失效。它们仍指向<code>swap</code>操作之前所指向的那些元素。但是，在<code>swap</code>之后，这些元素已经属于不同的容器了。例如，假定<code>iter</code>在<code>swap</code>之前指向<code>svec1[3]</code>的<code>string</code>，那么在<code>swap</code>之后它指向<code>svec2[3]</code>的元素。与其他容器不同，对一个<code>string</code>调用<code>swap</code>会导致迭代器、引用和指针失效。</p>
<p>与其他容器不同，<code>swap</code>两个<code>array</code>会真正交换它们的元素。因此，交换两个<code>array</code>所需的时间与<code>array</code>中元素的数目成正比。</p>
<p>因此，对于<code>array</code>，在<code>swap</code>操作之后，指针引用和迭代器所绑定的元素保持不变但元素值已经与另一个<code>array</code>中对应元素的值进行了交换。</p>
<p>在新标准库中，容器既提供成员函数版本的<code>swap</code>，也提供非成员版本的<code>swap</code>。而早期标准库版本只提供成员函数版本的<code>swap</code>。<strong>非成员版本的<code>swap</code>在泛型编程中是非常重要的。统一使用非成员版本的<code>swap</code>是一个好习惯。</strong></p>
<p>关系运算符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v3 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v4 = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>&#125;;</span><br><span class="line">v1 &lt; v2     <span class="comment">//true</span></span><br><span class="line">v1 &lt; v3     <span class="comment">//false</span></span><br><span class="line">v1 == v4    <span class="comment">//true</span></span><br><span class="line">v1 == v2    <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方式与<code>string</code>的关系运算类似:</p>
<ul>
<li>如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等；否则两个容器不等。</li>
<li>如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。</li>
<li>如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果。</li>
</ul>
<p>只有当容器的元素类型也定义了相应的比较运算符时，才可以用关系运算符比较两个容器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Sales_data&gt; storeA, storeB;</span><br><span class="line"><span class="comment">/*------ some code ------*/</span></span><br><span class="line"><span class="keyword">if</span>(storeA &lt; storeB)&#123;<span class="comment">/*---*/</span>&#125; <span class="comment">//错误！Sales_data没有定义&lt;运算符</span></span><br></pre></td></tr></table></figure>
<h2 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h2><p><img src="https://bu.dusays.com/2023/04/15/643a60508ca4f.png" alt="17-37.png"></p>
<p>由于 string 是一个字符容器，我们也可以用<code>push_back</code>在 string 末尾添加字符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pluralize</span><span class="params">(<span class="type">size_t</span> cnt, string&amp; word)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;<span class="number">1</span>)</span><br><span class="line">        word.<span class="built_in">push_back</span>(<span class="string">&#x27;s&#x27;</span>);  <span class="comment">//等价于 word += &#x27;s&#x27;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>容器元素是拷贝。</strong></p>
<p><code>list</code>、<code>forward_list</code>、<code>deque</code>容器支持将元素插到容器头部：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; ilist;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> ix = <span class="number">0</span>; ix != <span class="number">4</span>; ++ix)</span><br><span class="line">    ilist.<span class="built_in">push_front</span>(ix);</span><br><span class="line"><span class="comment">//执行完毕后，ilist保存序列 3、2、1、0</span></span><br></pre></td></tr></table></figure>
<p><code>insert</code>成员提供了更一般的功能：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert 函数将元素插入到迭代器所指定的位置之前</span></span><br><span class="line">slist.<span class="built_in">insert</span>(iter, <span class="string">&quot;Hello!&quot;</span>); <span class="comment">//将&quot;Hello!&quot;添加到iter之前的位置</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; svec;</span><br><span class="line">list&lt;string&gt; slist;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于调用 slist.push_front(&quot;Hello!&quot;);</span></span><br><span class="line">slist.<span class="built_in">insert</span>(slist.<span class="built_in">begin</span>(), <span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//vector不支持push_front，但可以插入到begin()之前</span></span><br><span class="line">svec.<span class="built_in">insert</span>(svec.<span class="built_in">begin</span>(), <span class="string">&quot;Hello!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>插入范围元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将10个元素插入到svec的末尾，并将所有元素都初始化为&quot;Anna&quot;</span></span><br><span class="line">svec.<span class="built_in">insert</span>(svec.<span class="built_in">end</span>(), <span class="number">10</span>, <span class="string">&quot;Anna&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受一对迭代器，或一个初始化列表</span></span><br><span class="line">vector&lt;string&gt; v = &#123;<span class="string">&quot;quasi&quot;</span>, <span class="string">&quot;simba&quot;</span>, <span class="string">&quot;frollo&quot;</span>, <span class="string">&quot;scar&quot;</span>&#125;;</span><br><span class="line"><span class="comment">//将v的最后两个元素添加到slist的开始位置</span></span><br><span class="line">slist.<span class="built_in">insert</span>(slist.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()<span class="number">-2</span>, v.<span class="built_in">end</span>()); <span class="comment">//插入元素会保持v中原有顺序</span></span><br><span class="line">slist.<span class="built_in">insert</span>(slist.<span class="built_in">end</span>(), &#123;<span class="string">&quot;these&quot;</span>, <span class="string">&quot;words&quot;</span>, <span class="string">&quot;will&quot;</span>, <span class="string">&quot;go&quot;</span>, <span class="string">&quot;at&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行时错误：迭代器表示要拷贝的范围，不能指向与目的位置相同的容器</span></span><br><span class="line">slist.<span class="built_in">insert</span>(slist.<span class="built_in">begin</span>(), slist.<span class="built_in">begin</span>(), slist.<span class="built_in">end</span>()); <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>
<p>使用<code>insert</code>返回值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++11，insert返回新加入元素的迭代器，如果不插入任何元素，返回第一个参数</span></span><br><span class="line">list&lt;string&gt; lst;</span><br><span class="line"><span class="keyword">auto</span> iter = lst.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;word)&#123;</span><br><span class="line">    iter = lst.<span class="built_in">insert</span>(iter, word);  <span class="comment">//等价于调用 push_front</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>emplace</code>操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在c的末尾构造一个Sales_data对象</span></span><br><span class="line">c.<span class="built_in">emplace_back</span>(<span class="string">&quot;101-1-1&quot;</span>, <span class="number">24</span>, <span class="number">15.99</span>);</span><br><span class="line"></span><br><span class="line">c.<span class="built_in">push_back</span>(<span class="string">&quot;101-1-1&quot;</span>, <span class="number">24</span>, <span class="number">15.99</span>);  <span class="comment">//错误！</span></span><br><span class="line">c.<span class="built_in">push_back</span>(<span class="built_in">Sales_data</span>(<span class="string">&quot;101-1-1&quot;</span>, <span class="number">24</span>, <span class="number">15.99</span>)); <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">c.<span class="built_in">emplace_back</span>();  <span class="comment">//使用Sales_data的默认构造函数</span></span><br><span class="line">c.<span class="built_in">emplace</span>(iter, <span class="string">&quot;101-1-1&quot;</span>); <span class="comment">//使用Sales_data(string)</span></span><br><span class="line">c.<span class="built_in">emplace_front</span>(<span class="string">&quot;101-1-1&quot;</span>, <span class="number">24</span>, <span class="number">15.99</span>);</span><br></pre></td></tr></table></figure>
<p>【练习9.22】 一个有点奇怪的题目，闲得慌可以看看。</p>
<p>访问元素：</p>
<p><img src="https://bu.dusays.com/2023/04/17/643d3a4c2fccc.png" alt="17-38.png"></p>
<p>访问成员函数返回的是引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!c.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    c.<span class="built_in">front</span>() = <span class="number">42</span>; <span class="comment">//改变了</span></span><br><span class="line">    <span class="keyword">auto</span> &amp;v = c.<span class="built_in">back</span>();</span><br><span class="line">    v = <span class="number">1024</span>;  <span class="comment">//改变了c中的元素</span></span><br><span class="line">    <span class="keyword">auto</span> v2 = c.<span class="built_in">back</span>(); <span class="comment">//v2不是一个引用，它是c.back()的一个拷贝</span></span><br><span class="line">    v2 = <span class="number">0</span>; <span class="comment">//未改变c中的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，使用 auto 变量保存这些函数的返回值，如果希望使用此变量改变元素的值，应定义为引用类型。</p>
<p><img src="https://bu.dusays.com/2023/04/17/643d3e239c31d.png" alt="17-39.png" title="顺序容器的删除操作"></p>
<p>从容器内部删除元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用后，elem1指向原先elem2所指向的位置</span></span><br><span class="line">elem1 = slist.<span class="built_in">erase</span>(elem1, elem2);</span><br></pre></td></tr></table></figure>
<p>特殊的<code>forward_list</code>操作：</p>
<p>关于这些操作的实现细节，请参阅《C++ Primer》第313页。</p>
<p><img src="https://sway.office.com/s/CROZFNBDynghyW67/images/_ovcx7pXmLYaEm" alt="17-40"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">forward_list&lt;<span class="type">int</span>&gt; flst = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> prev = flst.<span class="built_in">before_begin</span>();</span><br><span class="line"><span class="keyword">auto</span> curr = flst.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(curr != flst.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="keyword">if</span>(*curr%<span class="number">2</span>)</span><br><span class="line">        curr = flst.<span class="built_in">erase_after</span>(prev);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【练习9.28】编写函数，接受一个<code>forward_list&lt;string&gt;</code>和两个<code>string</code>共三个参数。函数应在链表中查找第一个<code>string</code>，并将第二个<code>string</code>插入到紧接着第一个<code>string</code>之后的位置。若第一个<code>string</code>未在链表中，则将第二个<code>string</code>插入到链表末尾。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_and_insert</span><span class="params">(forward_list&lt;string&gt;&amp; sflst, <span class="type">const</span> string&amp; s1, <span class="type">const</span> string&amp; s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> prev = sflst.<span class="built_in">before_begin</span>();</span><br><span class="line">    <span class="keyword">auto</span> curr = sflst.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">bool</span> inserted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(curr!=sflst.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(*curr==s1)&#123;</span><br><span class="line">            curr = sflst.<span class="built_in">insert_after</span>(curr, s2);</span><br><span class="line">            inserted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!inserted)</span><br><span class="line">        sflst.<span class="built_in">insert_after</span>(prev, s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    forward_list&lt;string&gt; sflst = &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;!&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">test_and_insert</span>(sflst, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Sucrose&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> curr=sflst.<span class="built_in">cbegin</span>(); curr!=sflst.<span class="built_in">cend</span>(); curr++)&#123;</span><br><span class="line">        cout &lt;&lt; *curr &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//Hello Sucrose ! world ! </span></span><br></pre></td></tr></table></figure>
<p>改变容器大小：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">ilist</span><span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>; <span class="comment">//10个int，每个值都是42</span></span><br><span class="line">ilist.<span class="built_in">resize</span>(<span class="number">15</span>);     <span class="comment">//将5个值为0的元素添加到ilist的末尾</span></span><br><span class="line">ilist.<span class="built_in">resize</span>(<span class="number">25</span>, <span class="number">-1</span>); <span class="comment">//将10个值为-1的元素添加到ilist的末尾</span></span><br><span class="line">ilist.<span class="built_in">resize</span>(<span class="number">5</span>);      <span class="comment">//从ilist末尾删除20个元素</span></span><br></pre></td></tr></table></figure>
<p><img src="https://bu.dusays.com/2023/04/29/644ce58b15821.png" alt="17-41.png" title="顺序容器大小操作"></p>
<p><strong>容器操作可能使迭代器失效。</strong> 这在不同情况下会有不同的表现，如果你是一个纠结于此类无聊问题的人，请翻阅《C++ primer（第五版）》第315页。</p>
<p><strong>不要保存 end 返回的迭代器。</strong> 添加或删除元素的循环程序必须反复调用 end ，而不能在循环之前保存 end 返回的选代器，一直当作容器末尾使用。通常 C++ 标准库的实现中 end() 操作都很快，部分就是因为这个原因。</p>
<h2 id="vector对象是如何增长的"><a href="#vector对象是如何增长的" class="headerlink" title="vector对象是如何增长的"></a>vector对象是如何增长的</h2><p>vector 的底层其实仍然是定长数组，它能够实现动态扩容的原因是增加了避免数量溢出的操作。首先需要指明的是 vector 中元素的数量（长度）n 与它已分配内存最多能包含元素的数量（容量）N 是不一致的，vector 会分开存储这两个量。当向 vector 中添加元素时，如发现 n&gt;N，那么容器会分配一个尺寸为 2N 的数组，然后将旧数据从原本的位置拷贝到新的数组中，再将原来的内存释放。尽管这个操作的渐进复杂度是 O(n)，但是可以证明其均摊复杂度为 O(1)，而在末尾删除元素和访问元素则都仍然是 O(1) 的开销。 因此，只要对 vector 的尺寸估计得当并善用<code>resize()</code>和<code>reserve()</code>，就能使得 vector 的效率与定长数组不会有太大差距。</p>
<p><img src="https://bu.dusays.com/2023/05/01/644f3010c036d.png" alt="17-42.png" title="容器大小管理操作"></p>
<p><code>reserve</code>并不改变容器中元素的数量，它仅影响 vector 预先分配多大的内存空间。</p>
<blockquote>
<p>只有当需要的内存空间超过当前容量时，<code>reserve</code>调用才会改变 vector 的容量。如果需求大小大于当前容量，<code>reserve</code>至少分配与需求一样大的内存空间（可能更大）。<br>如果需求大小小于或等于当前容量，<code>reserve</code>什么也不做。特别是，当需求大小小于当前容量时，容器不会退回内存空间。因此，在调用<code>reserve</code>之后，<code>capacity</code>将会大于或等于传递给<code>reserve</code>的参数。<br>这样，调用<code>reserve</code>永远也不会减少容器占用的内存空间。类似的，<code>resize</code>成员函数只改变容器中元素的数目，而不是容器的容量。我们同样不能使用<code>resize</code>来减少容器预留的内存空间。<br>在新标准库中，我们可以调用<code>shrink_to_fit</code>来要求deque、vector或string退回不需要的内存空间。此函数指出我们不再需要任何多余的内存空间。但是，具体的实现可以选择忽略此请求。也就是说，调用<code>shrink_to_fit</code>也并不保证一定退回内存空间。</p>
</blockquote>
<p><code>capacity</code>和<code>size</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line"><span class="comment">//size应该为0，capacity的值依赖于具体实现</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ivec: size: &quot;</span> &lt;&lt; ivec.<span class="built_in">size</span>()</span><br><span class="line">     &lt;&lt; <span class="string">&quot; capacity: &quot;</span> &lt;&lt; ivec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向ivec添加24个元素</span></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::size_type ix = <span class="number">0</span>; ix!=<span class="number">24</span>; ix++)</span><br><span class="line">    ivec.<span class="built_in">push_back</span>(ix);</span><br><span class="line"></span><br><span class="line"><span class="comment">//size应该为24，capacity应该大于等于24，具体值依赖于标准库实现</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ivec: size: &quot;</span> &lt;&lt; ivec.<span class="built_in">size</span>()</span><br><span class="line">     &lt;&lt; <span class="string">&quot; capacity: &quot;</span> &lt;&lt; ivec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------- possible output ----------</span></span><br><span class="line"><span class="comment">ivec: size: 0 capacity: 0</span></span><br><span class="line"><span class="comment">ivec: size: 24 capacity: 32</span></span><br><span class="line"><span class="comment">------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//预分配一些额外空间</span></span><br><span class="line">ivec.<span class="built_in">reserve</span>(<span class="number">50</span>); <span class="comment">//将capacity至少设定为50，可能会更大</span></span><br><span class="line"><span class="comment">//size应该为24，capacity应该大于等于50，具体值依赖于标准库实现</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ivec: size: &quot;</span> &lt;&lt; ivec.<span class="built_in">size</span>()</span><br><span class="line">     &lt;&lt; <span class="string">&quot; capacity: &quot;</span> &lt;&lt; ivec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------- possible output ----------</span></span><br><span class="line"><span class="comment">ivec: size: 24 capacity: 50</span></span><br><span class="line"><span class="comment">------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来可以用光这些预留空间</span></span><br><span class="line"><span class="keyword">while</span>(ivec.<span class="built_in">size</span>()!=ivec.<span class="built_in">capacity</span>())</span><br><span class="line">    ivec.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//capacity应该未改变</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ivec: size: &quot;</span> &lt;&lt; ivec.<span class="built_in">size</span>()</span><br><span class="line">     &lt;&lt; <span class="string">&quot; capacity: &quot;</span> &lt;&lt; ivec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------- possible output ----------</span></span><br><span class="line"><span class="comment">ivec: size: 50 capacity: 50</span></span><br><span class="line"><span class="comment">------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">ivec.<span class="built_in">push_back</span>(<span class="number">42</span>); <span class="comment">//再添加一个元素</span></span><br><span class="line"><span class="comment">//size应该为51，capacity应该大于等于51，具体值依赖于标准库实现</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ivec: size: &quot;</span> &lt;&lt; ivec.<span class="built_in">size</span>()</span><br><span class="line">     &lt;&lt; <span class="string">&quot; capacity: &quot;</span> &lt;&lt; ivec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------- possible output ----------</span></span><br><span class="line"><span class="comment">ivec: size: 51 capacity: 100</span></span><br><span class="line"><span class="comment">------------------------------------*/</span></span><br><span class="line"></span><br><span class="line">ivec.<span class="built_in">shrink_to_fit</span>(); <span class="comment">//要求归还内存</span></span><br><span class="line"><span class="comment">//size应该未改变，capacity的值依赖于具体实现</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ivec: size: &quot;</span> &lt;&lt; ivec.<span class="built_in">size</span>()</span><br><span class="line">     &lt;&lt; <span class="string">&quot; capacity: &quot;</span> &lt;&lt; ivec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//调用 shrink_to_fit() 只是一个请求，标准库并不保证退还内存</span></span><br></pre></td></tr></table></figure>
<p>只有在执行<code>insert</code>操作时<code>size</code>与<code>capacity</code>相等，或者调用<code>resize</code>或<code>reserve</code>时给定的大小超过当前<code>capacity</code>，vector 才可能重新分配内存空间。会分配多少超过给定容量的额外空间，取决于具体实现。</p>
<h2 id="额外的string操作"><a href="#额外的string操作" class="headerlink" title="额外的string操作"></a>额外的string操作</h2><p><img src="https://bu.dusays.com/2023/05/21/646980f6ba5b7.png" alt="17-43.png" title="构造string的其他方法"></p>
<p><img src="https://bu.dusays.com/2023/05/21/64698210df73b.png" alt="17-44.png" title="当作手册来查"></p>
<p>substr 操作：</p>
<p><img src="https://bu.dusays.com/2023/05/21/6469837ab648d.png" alt="17-45.png" title="子字符串操作"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line">string s2 = s.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// s2 = &quot;hello&quot;</span></span><br><span class="line">string s3 = s.<span class="built_in">substr</span>(<span class="number">6</span>); <span class="comment">// s3 = &quot;world&quot;</span></span><br><span class="line">string s4 = s.<span class="built_in">substr</span>(<span class="number">6</span>, <span class="number">11</span>); <span class="comment">// s4 = &quot;world&quot;</span></span><br><span class="line">string s5 = s.<span class="built_in">substr</span>(<span class="number">12</span>);  <span class="comment">//抛出一个 out_of_range 异常</span></span><br></pre></td></tr></table></figure>
<p>【练习9.41】编写程序，从一个<code>vector&lt;char&gt;</code>初始化一个<code>string</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vector提供了data成员函数，返回其内存空间的首地址。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">char</span>&gt; chvec = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    <span class="function">std::string <span class="title">s1</span><span class="params">(chvec.data(), chvec.size())</span></span>;</span><br><span class="line">    std::cout &lt;&lt; s1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*---- output -----</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">------------------*/</span></span><br></pre></td></tr></table></figure>
<p>【练习9.42】假定你希望每次读取一个字符存入一个 string 中，而且知道最少需要读取 100 个字符，如何提高程序性能？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">input_string</span><span class="params">(string&amp; s)</span></span>&#123;</span><br><span class="line">    s.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;c)&#123;</span><br><span class="line">        s.<span class="built_in">push_back</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">input_string</span>(s);</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*--------------------------------------</span></span><br><span class="line"><span class="comment">asdfa dfhdfh easdf;d&gt;</span></span><br><span class="line"><span class="comment">dfaf</span></span><br><span class="line"><span class="comment">asdgasgas</span></span><br><span class="line"><span class="comment">^Z</span></span><br><span class="line"><span class="comment">asdfadfhdfheasdf;d&gt;dfafasdgasgas</span></span><br><span class="line"><span class="comment">--------------------------------------*/</span></span><br></pre></td></tr></table></figure>
<p>除了接受迭代器的<code>insert</code>和<code>erase</code>版本外，string 还提供了接受下标的版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">size</span>(), <span class="number">5</span>, <span class="string">&#x27;!&#x27;</span>); <span class="comment">//在s末尾插入5个感叹号</span></span><br><span class="line">s.<span class="built_in">erase</span>(s.<span class="built_in">size</span>()<span class="number">-5</span>, <span class="number">5</span>); <span class="comment">//从s删除最后5个字符</span></span><br></pre></td></tr></table></figure>
<p>还提供了接受 C 风格字符数组的<code>insert</code>和<code>assign</code>版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* cp = <span class="string">&quot;Stately, plump Buck&quot;</span>;</span><br><span class="line">s.<span class="built_in">assign</span>(cp, <span class="number">7</span>); <span class="comment">// s == &quot;Stately&quot;</span></span><br><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">size</span>(), cp+<span class="number">7</span>);  <span class="comment">// s == &quot;Stately, plump Buck&quot;</span></span><br></pre></td></tr></table></figure>
<p>我们也可以指定来自其他 string 或子字符串的字符插入到当前 string 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;some string&quot;</span>, s2 = <span class="string">&quot;some other string&quot;</span>;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">0</span>, s2); <span class="comment">//在s中位置0之前插入s2的拷贝</span></span><br><span class="line"><span class="comment">//在s[0]之前插入s2中s2[0]开始的s2.size()个字符</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">0</span>, s2, <span class="number">0</span>, s2.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure>
<p><code>append</code>和<code>replace</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//append 操作是在 string 末尾进行插入操作的一种简写形式</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;C++ Primer&quot;</span>)</span>, s2 </span>= s;</span><br><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">size</span>(), <span class="string">&quot; 4th Ed.&quot;</span>); <span class="comment">// s == &quot;C++ Primer 4th Ed.&quot;</span></span><br><span class="line">s2.<span class="built_in">append</span>(<span class="string">&quot; 4th Ed.&quot;</span>);  <span class="comment">// 等价方法，s == s2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//replace 操作是调用 erase 和 insert 的一种简写形式</span></span><br><span class="line"><span class="comment">//将 &quot;4th&quot; 替换为 &quot;5th&quot; 的等价方法</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">11</span>, <span class="number">3</span>);       <span class="comment">// s == &quot;C++ Primer Ed.&quot;</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">11</span>, <span class="string">&quot;5th&quot;</span>);  <span class="comment">// s == &quot;C++ Primer 5th Ed.&quot;</span></span><br><span class="line"><span class="comment">//从位置 11 开始，删除3个字符并插入 &quot;5th&quot;</span></span><br><span class="line">s2.<span class="built_in">replace</span>(<span class="number">11</span>, <span class="number">3</span>, <span class="string">&quot;5th&quot;</span>); <span class="comment">//等价方法：s==s2</span></span><br><span class="line"><span class="comment">//s.replace(11, 3, &quot;Fifth&quot;);  也可以，长度无需一样</span></span><br></pre></td></tr></table></figure>
<p><img src="https://bu.dusays.com/2023/06/10/648462bba1cf7.png" alt="17-46.png" title="修改string的操作"></p>
<p>【练习9.43 &amp; 练习9.44】如果你真的觉得题目描述有看头的话，就翻书看吧。</p>
<p>博主的代码，使用 KMP 算法实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; mynext, std::string&amp; t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    mynext.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;t.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; t[i]!=t[j]) j=mynext[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(t[i]==t[j]) j++;</span><br><span class="line">        mynext.<span class="built_in">push_back</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function">std::stack&lt;<span class="type">int</span>&gt; <span class="title">kmpfind</span><span class="params">(std::string&amp; s, std::string&amp; t)</span></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; mynext;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; tmpans;</span><br><span class="line">    <span class="built_in">getNext</span>(mynext, t);</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != t[j]) &#123;</span><br><span class="line">            j = mynext[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==t[j]) j++;</span><br><span class="line">        <span class="keyword">if</span> (j==t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            tmpans.<span class="built_in">push</span>(i-t.<span class="built_in">size</span>()+<span class="number">1</span>);</span><br><span class="line">            j = mynext[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmpans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">convert2sth</span><span class="params">(std::string&amp; s, std::string&amp; oldVal, std::string&amp; newVal)</span></span>&#123;</span><br><span class="line">    std::stack&lt;<span class="type">int</span>&gt; ayaka = <span class="built_in">kmpfind</span>(s, oldVal);</span><br><span class="line">    <span class="keyword">while</span>(!ayaka.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        s.<span class="built_in">replace</span>(ayaka.<span class="built_in">top</span>(), oldVal.<span class="built_in">size</span>(), newVal);</span><br><span class="line">        ayaka.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::string s, oldVal, newVal;</span><br><span class="line">    std::cin &gt;&gt; s &gt;&gt; oldVal &gt;&gt; newVal;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">convert2sth</span>(s, oldVal, newVal); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  测试样例：前三行是输入，末行是输出</span></span><br><span class="line"><span class="comment"> *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *</span></span><br><span class="line"><span class="comment"> *  ayaka_is_my_waifu_.ayakaayaka_ayakayaka_ayaka123ayaka</span></span><br><span class="line"><span class="comment"> *  ayaka</span></span><br><span class="line"><span class="comment"> *  xiangling</span></span><br><span class="line"><span class="comment"> *  xiangling_is_my_waifu_.xianglingxiangling_xianglingiangling_xiangling123xiangling</span></span><br><span class="line"><span class="comment"> *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *</span></span><br><span class="line"><span class="comment"> *  虽然没有经过仔细的测试，但这个样例真的很令人信服/幸福  (* /ω＼*)</span></span><br><span class="line"><span class="comment"> *  最后我不知道这样的代码好不好，但肯定没有我的算法板子跑的快</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>当然，我的这么一通操作到底是不是画蛇添足，不得而知。相关的讨论：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/392846851">C++string中find函数是用什么算法实现的？他的时间复杂度如何？实际比手写KMP效率相比如何？</a></p>
<p>书中给出的参考答案：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前略</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">replace_string</span><span class="params">(string&amp; s, <span class="type">const</span> string&amp; oldVal, <span class="type">const</span> string&amp; newVal)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((p=s.<span class="built_in">find</span>(oldVal, p))!=string::npos)&#123;</span><br><span class="line">        s.<span class="built_in">replace</span>(p, oldVal.<span class="built_in">size</span>(), newVal);</span><br><span class="line">        p += newVal.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后略</span></span><br></pre></td></tr></table></figure>
<p>【练习9.45 &amp; 练习9.46】 题干没什么可看的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">name_string</span><span class="params">(string&amp; name, <span class="type">const</span> string&amp; prefix, <span class="type">const</span> string&amp; suffix)</span></span>&#123;</span><br><span class="line">    name.<span class="built_in">insert</span>(name.<span class="built_in">begin</span>(), <span class="number">1</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    name.<span class="built_in">insert</span>(name.<span class="built_in">begin</span>(), prefix.<span class="built_in">begin</span>(), prefix.<span class="built_in">end</span>());</span><br><span class="line">    name.<span class="built_in">append</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    name.<span class="built_in">append</span>(suffix.<span class="built_in">begin</span>(), suffix.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// ===================================== //</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">name_string</span><span class="params">(string&amp; name, <span class="type">const</span> string&amp; prefix, <span class="type">const</span> string&amp; suffix)</span></span>&#123;</span><br><span class="line">    name.<span class="built_in">insert</span>(<span class="number">0</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    name.<span class="built_in">insert</span>(<span class="number">0</span>, prefix);</span><br><span class="line">    name.<span class="built_in">insert</span>(name.<span class="built_in">size</span>(), <span class="string">&quot; &quot;</span>);</span><br><span class="line">    name.<span class="built_in">insert</span>(name.<span class="built_in">size</span>(), suffix);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p><img src="https://bu.dusays.com/2023/06/12/6486d4c032bb9.png" alt="17-47.png" title="string 搜索操作"></p>
<p>string 搜索函数返回一个<code>string::size_type</code>值，该类型是一个<code>unsigned</code>类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">name</span><span class="params">(<span class="string">&quot;AnnaBelle&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> pos1 = name.<span class="built_in">find</span>(<span class="string">&quot;Anna&quot;</span>); <span class="comment">// pos1 == 0</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">numbers</span><span class="params">(<span class="string">&quot;0123456789&quot;</span>)</span>, <span class="title">name</span><span class="params">(<span class="string">&quot;r2d2&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//返回1，即，name 中第一个数字的下标</span></span><br><span class="line"><span class="keyword">auto</span> pos = name.<span class="built_in">find_first_of</span>(numbers);</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">dept</span><span class="params">(<span class="string">&quot;03714p3&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//返回5，字符 &#x27;p&#x27; 的下标</span></span><br><span class="line"><span class="keyword">auto</span> pos = dept.<span class="built_in">find_first_not_of</span>(numbers);</span><br></pre></td></tr></table></figure>
<p>查找一整个字符串的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">numbers</span><span class="params">(<span class="string">&quot;0123456789&quot;</span>)</span>, <span class="title">name</span><span class="params">(<span class="string">&quot;r2d2&quot;</span>)</span></span>;</span><br><span class="line">string::size_type pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((pos=name.<span class="built_in">find_first_of</span>(numbers, pos))!=string::npos)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;found number at index: &quot;</span> &lt;&lt; pos &lt;&lt; <span class="string">&quot; element is &quot;</span> &lt;&lt; name[pos] &lt;&lt; endl;</span><br><span class="line">    pos++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*       output</span></span><br><span class="line"><span class="comment"> *  *  *  *  *  *  *  *</span></span><br><span class="line"><span class="comment"> *  found number at index: 1 element is 2</span></span><br><span class="line"><span class="comment"> *  found number at index: 3 element is 2</span></span><br><span class="line"><span class="comment"> *  *  *  *  *  *  *  *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>逆向搜索：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">river</span><span class="params">(<span class="string">&quot;Mississippi&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> first_pos = river.<span class="built_in">find</span>(<span class="string">&quot;is&quot;</span>);  <span class="comment">//返回 1</span></span><br><span class="line"><span class="keyword">auto</span> last_pos = river.<span class="built_in">rfind</span>(<span class="string">&quot;is&quot;</span>);  <span class="comment">//返回 4</span></span><br></pre></td></tr></table></figure>
<p>【练习9.49】 如果一个字母延伸到中线之上，如 d 或 f ，则称其有上出头部分（ascender）。如果一个字母延伸到中线之下，称其有下出头部分（descender）。编写程序，读入一个单词文件，输出最长的既不包括上出头部分，也不包括下出头部分的单词。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find_longest_word</span><span class="params">(ifstream&amp; in)</span></span>&#123;</span><br><span class="line">    string s, longest_word;</span><br><span class="line">    <span class="type">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (in &gt;&gt; s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">find_first_of</span>(<span class="string">&quot;bdfghjklpqty&quot;</span>)!=string::npos) <span class="keyword">continue</span>;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(maxlen &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            maxlen = s.<span class="built_in">size</span>();</span><br><span class="line">            longest_word = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;the longest string is: &quot;</span> &lt;&lt; longest_word &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(argv[<span class="number">1</span>])</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!in)&#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;cannot open file.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">find_longest_word</span>(in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">asfdfva  asdfe mm</span><br><span class="line">asdf/:o? asdf sfg aabb jjj</span><br><span class="line">kkk</span><br><span class="line">s</span><br><span class="line">d</span><br><span class="line">asdfasf werg aaa</span><br></pre></td></tr></table></figure>
<p>命令及输出：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\arrogance&gt; <span class="built_in">cd</span> D:\c++code\exercise9<span class="literal">-49</span></span><br><span class="line"><span class="built_in">PS</span> D:\c++code\exercise9<span class="literal">-49</span>&gt; g++ <span class="number">949</span>main.cpp <span class="literal">-o</span> <span class="number">949</span>prog</span><br><span class="line"><span class="built_in">PS</span> D:\c++code\exercise9<span class="literal">-49</span>&gt; .\<span class="number">949</span>prog.exe <span class="number">949</span>in.txt</span><br><span class="line">mm s aaa</span><br><span class="line">the longest string is: aaa</span><br></pre></td></tr></table></figure>
<p><code>compare</code>函数：</p>
<p><img src="https://bu.dusays.com/2023/06/12/6486df8184212.png" alt="17-48.png"></p>
<p>数值转换：</p>
<p><img src="https://bu.dusays.com/2023/06/12/648737706da17.png" alt="17-49.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">    string s = <span class="built_in">to_string</span>(i);  cout &lt;&lt; s &lt;&lt;endl;</span><br><span class="line">    <span class="type">double</span> d = <span class="built_in">stod</span>(s);  cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    <span class="type">double</span> akashi = <span class="number">42.23</span>;</span><br><span class="line">    s = <span class="built_in">to_string</span>(akashi);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">stod</span>(s) &lt;&lt; endl &lt;&lt; <span class="built_in">stoi</span>(s) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string s2 = <span class="string">&quot;pi=3.14!!!??&quot;</span>;</span><br><span class="line">    d = <span class="built_in">stod</span>(s2.<span class="built_in">substr</span>(s2.<span class="built_in">find_first_of</span>(<span class="string">&quot;+-.0123456789&quot;</span>)));</span><br><span class="line">    cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  output</span></span><br><span class="line"><span class="comment"> *  *  *  *  *  *</span></span><br><span class="line"><span class="comment"> *  42</span></span><br><span class="line"><span class="comment"> *  42</span></span><br><span class="line"><span class="comment"> *  42.23</span></span><br><span class="line"><span class="comment"> *  42</span></span><br><span class="line"><span class="comment"> *  3.14</span></span><br><span class="line"><span class="comment"> *  *  *  *  *  *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>【练习9.51】设计一个类，它有三个 unsigned 成员，分别表示月、日、年。为其编写构造函数，接受一个表示日期的 string 参数。你的构造函数应该能处理不同数据格式，如<code>January 1,1990</code>、<code>1/1/1900</code>、<code>Jan 1 1900</code>等。 </p>
<p>我的代码，注意没有检查格式错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mdate</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp; os, <span class="type">const</span> mdate&amp; item)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">mdate</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">mdate</span>(<span class="type">const</span> std::string&amp; s)&#123;</span><br><span class="line">        std::string::size_type pos = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        std::string wilddata[<span class="number">3</span>] = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((pos=s.<span class="built_in">find_first_of</span>(<span class="string">&quot; ,/&quot;</span>, pos))!=std::string::npos)&#123;</span><br><span class="line">            wilddata[k]=s.<span class="built_in">substr</span>(pre, pos-pre);</span><br><span class="line">            pos++; k++;</span><br><span class="line">            pre = pos;</span><br><span class="line">        &#125;</span><br><span class="line">        wilddata[<span class="number">2</span>] = s.<span class="built_in">substr</span>(pre);</span><br><span class="line">        dd = <span class="built_in">stol</span>(wilddata[<span class="number">1</span>]);</span><br><span class="line">        yy = <span class="built_in">stol</span>(wilddata[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span>(mm2num.<span class="built_in">count</span>(wilddata[<span class="number">0</span>])!=<span class="number">0</span>)&#123;</span><br><span class="line">            mm = mm2num[wilddata[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> mm = <span class="built_in">stol</span>(wilddata[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> yy;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mm;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> dd;</span><br><span class="line">    <span class="type">static</span> std::map&lt;std::string,<span class="type">unsigned</span> <span class="type">long</span>&gt; mm2num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::map&lt;std::string, <span class="type">unsigned</span> <span class="type">long</span>&gt; mdate::mm2num = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;January&quot;</span>, <span class="number">1</span>&#125;,     &#123;<span class="string">&quot;Jan&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;February&quot;</span>, <span class="number">2</span>&#125;,    &#123;<span class="string">&quot;Feb&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;March&quot;</span>, <span class="number">3</span>&#125;,       &#123;<span class="string">&quot;Mar&quot;</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;April&quot;</span>, <span class="number">4</span>&#125;,       &#123;<span class="string">&quot;Apr&quot;</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;May&quot;</span>, <span class="number">5</span>&#125;,         &#123;<span class="string">&quot;May&quot;</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;June&quot;</span>, <span class="number">6</span>&#125;,        &#123;<span class="string">&quot;Jun&quot;</span>, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;July&quot;</span>, <span class="number">7</span>&#125;,        &#123;<span class="string">&quot;Jul&quot;</span>, <span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;August&quot;</span>, <span class="number">8</span>&#125;,      &#123;<span class="string">&quot;Aug&quot;</span>, <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;September&quot;</span>, <span class="number">9</span>&#125;,   &#123;<span class="string">&quot;Sept&quot;</span>, <span class="number">9</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;October&quot;</span>, <span class="number">10</span>&#125;,    &#123;<span class="string">&quot;Oct&quot;</span>, <span class="number">10</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;November&quot;</span>, <span class="number">11</span>&#125;,   &#123;<span class="string">&quot;Nov&quot;</span>, <span class="number">11</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;December&quot;</span>, <span class="number">12</span>&#125;,   &#123;<span class="string">&quot;Dec&quot;</span>, <span class="number">12</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp; os, <span class="type">const</span> mdate&amp; item)</span></span>&#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;中文表述习惯为：&quot;</span> &lt;&lt; item.yy &lt;&lt; <span class="string">&quot;年&quot;</span> &lt;&lt; item.mm &lt;&lt; <span class="string">&quot;月&quot;</span> </span><br><span class="line">       &lt;&lt; item.dd &lt;&lt; <span class="string">&quot;日&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(std::cin,line))&#123;</span><br><span class="line">        <span class="keyword">if</span>(line==<span class="string">&quot;quit&quot;</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="function">mdate <span class="title">akashi</span><span class="params">(line)</span></span>;</span><br><span class="line">        <span class="built_in">print</span>(std::cout, akashi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入输出及命令行信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Oct 23 2003</span><br><span class="line">中文表述习惯为：2003年10月23日</span><br><span class="line">November 11 2018</span><br><span class="line">中文表述习惯为：2018年11月11日</span><br><span class="line">Jan 1,1998</span><br><span class="line">中文表述习惯为：1998年1月1日</span><br><span class="line">Aug,2/2015</span><br><span class="line">中文表述习惯为：2015年8月2日</span><br><span class="line">May/12 2098</span><br><span class="line">中文表述习惯为：2098年5月12日</span><br><span class="line">2 2 2001</span><br><span class="line">中文表述习惯为：2001年2月2日</span><br><span class="line">2/1/1023</span><br><span class="line">中文表述习惯为：1023年2月1日</span><br><span class="line">quit</span><br><span class="line"></span><br><span class="line">Press any key to continue . . .</span><br></pre></td></tr></table></figure>
<p>以下给出检查某些错误的可能思路：</p>
<ul>
<li>若某些特立独行的用户输入诸如<code>/////</code>之类的数据，或者连续多个空格等，会导致数组越界。为此需要重新编写 while 循环内的语句。</li>
<li>我们的思路是先将输入分成三块，然后分别在块内检查是否合法。如果依靠合法的分隔符都无法分为三块，则直接提示输入格式错误。</li>
<li>其他细节不表。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((pos=s.<span class="built_in">find_first_of</span>(<span class="string">&quot; ,/&quot;</span>, pos))!=std::string::npos)&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos!=pre) wilddata[k++]=s.<span class="built_in">substr</span>(pre, pos-pre);</span><br><span class="line">    pre = ++pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k!=<span class="number">2</span>)&#123;<span class="comment">/* error msg */</span>&#125;</span><br><span class="line">wilddata[<span class="number">2</span>] = s.<span class="built_in">substr</span>(pre);</span><br><span class="line"><span class="comment">/* check if wilddata[0,1,2] is valid */</span></span><br></pre></td></tr></table></figure>
<p>习题册给出的案例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 9_51head.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DATE_H_INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATE_H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">date</span>&#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, <span class="type">const</span> date&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">date</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">date</span>(string&amp; ds);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">y</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> year;&#125;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">m</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> month;&#125;</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="title">d</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> day;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> year, month, day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> string month_name[] = &#123;<span class="string">&quot;January&quot;</span>, <span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>,</span><br><span class="line">                             <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>, <span class="string">&quot;July&quot;</span>, <span class="string">&quot;August&quot;</span>, <span class="string">&quot;September&quot;</span>,</span><br><span class="line">                             <span class="string">&quot;October&quot;</span>, <span class="string">&quot;November&quot;</span>, <span class="string">&quot;December&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> string month_abbr[] = &#123;<span class="string">&quot;Jan&quot;</span>, <span class="string">&quot;Feb&quot;</span>, <span class="string">&quot;Mar&quot;</span>, <span class="string">&quot;Apr&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;Jun&quot;</span>,</span><br><span class="line">                             <span class="string">&quot;Jul&quot;</span>, <span class="string">&quot;Aug&quot;</span>, <span class="string">&quot;Sept&quot;</span>, <span class="string">&quot;Oct&quot;</span>, <span class="string">&quot;Nov&quot;</span>, <span class="string">&quot;Dec&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> days[] = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get_month</span><span class="params">(string&amp; ds, <span class="type">int</span>&amp; end_of_month)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">12</span>; i++)&#123;</span><br><span class="line">        <span class="comment">// 检查每个字符是否与月份简写相等</span></span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;month_abbr[i].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ds[j]!=month_abbr[i][j]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==month_abbr[i].<span class="built_in">size</span>())<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">12</span>) <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;不是合法月份名&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ds[j]==<span class="string">&#x27; &#x27;</span>)&#123;   <span class="comment">// 空白符，仅是月份简写</span></span><br><span class="line">        end_of_month = j+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(; j&lt;month_name[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        <span class="keyword">if</span>(ds[j]!=month_name[i][j]) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j==month_name[i].<span class="built_in">size</span>() &amp;&amp; ds[j]==<span class="string">&#x27; &#x27;</span>)&#123;  <span class="comment">//月份全称</span></span><br><span class="line">        end_of_month = j+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;不是合法月份名&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get_day</span><span class="params">(string&amp; ds, <span class="type">int</span> month, <span class="type">int</span>&amp; p)</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> q;</span><br><span class="line">    <span class="type">int</span> day = <span class="built_in">stoi</span>(ds.<span class="built_in">substr</span>(p), &amp;q); <span class="comment">//从p开始的部分转换为日期值</span></span><br><span class="line">    <span class="keyword">if</span>(day&lt;<span class="number">1</span> || day&gt;days[month])</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;不是合法日期值&quot;</span>);</span><br><span class="line">    p += q;</span><br><span class="line">    <span class="keyword">return</span> day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get_year</span><span class="params">(string&amp; ds, <span class="type">int</span>&amp; p)</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> q;</span><br><span class="line">    <span class="type">int</span> year = <span class="built_in">stoi</span>(ds.<span class="built_in">substr</span>(p), &amp;q); <span class="comment">//从p开始的部分转为年</span></span><br><span class="line">    <span class="keyword">if</span>(p+q&lt;ds.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;非法结尾内容&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">date::<span class="built_in">date</span>(string&amp; ds)&#123;</span><br><span class="line">    <span class="type">int</span> p;</span><br><span class="line">    <span class="type">size_t</span> q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((p=ds.<span class="built_in">find_first_of</span>(<span class="string">&quot;0123456789&quot;</span>))==string::npos)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;没有数字，非法日期&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p&gt;<span class="number">0</span>)&#123;                     <span class="comment">// 月份名格式</span></span><br><span class="line">        month = <span class="built_in">get_month</span>(ds, p);</span><br><span class="line">        day = <span class="built_in">get_day</span>(ds, month, p);</span><br><span class="line">        <span class="keyword">if</span>(ds[p]!=<span class="string">&#x27; &#x27;</span> &amp;&amp; ds[p]!=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;非法间隔符&quot;</span>);</span><br><span class="line">        p++;</span><br><span class="line">        year = <span class="built_in">get_year</span>(ds, p);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;                      <span class="comment">// 月份值格式</span></span><br><span class="line">        month = <span class="built_in">stoi</span>(ds, &amp;q);</span><br><span class="line">        p = q;</span><br><span class="line">        <span class="keyword">if</span>(month&lt;<span class="number">1</span> || month&gt;<span class="number">12</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;不是合法月份值&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(ds[p++]!=<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;非法间隔符&quot;</span>);</span><br><span class="line">        day = <span class="built_in">get_day</span>(ds, month, p);</span><br><span class="line">        <span class="keyword">if</span>(ds[p++]!=<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;非法间隔符&quot;</span>);</span><br><span class="line">        year = <span class="built_in">get_year</span>(ds, p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> date&amp; d)&#123;</span><br><span class="line">    out &lt;&lt; d.<span class="built_in">y</span>() &lt;&lt; <span class="string">&quot;年&quot;</span> &lt;&lt; d.<span class="built_in">m</span>() &lt;&lt; <span class="string">&quot;月&quot;</span> &lt;&lt; d.<span class="built_in">d</span>() &lt;&lt; <span class="string">&quot;日&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DATE_H_INCLUDED</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 9_51main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;9_51head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string dates[] = &#123;<span class="string">&quot;Jan 1,2014&quot;</span>, <span class="string">&quot;February 1 2014&quot;</span>, <span class="string">&quot;3/1/2014&quot;</span>,</span><br><span class="line">                    <span class="comment">//&quot;Jcn 1,2014&quot;,</span></span><br><span class="line">                    <span class="comment">//&quot;Janvary 1,2014&quot;,</span></span><br><span class="line">                    <span class="comment">//&quot;Jan 32,2014&quot;,</span></span><br><span class="line">                    <span class="comment">//&quot;Jan 1/2014&quot;,</span></span><br><span class="line">                      <span class="string">&quot;3 1 2014&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ds : dates)&#123;</span><br><span class="line">            <span class="function">date <span class="title">d1</span><span class="params">(ds)</span></span>;</span><br><span class="line">            cout &lt;&lt; d1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(invalid_argument e)&#123;</span><br><span class="line">        cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2014年1月1日</span><br><span class="line">2014年2月1日</span><br><span class="line">2014年3月1日</span><br><span class="line">非法间隔符</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意这个案例代码的格式是严格按照题目要求的，稍有不符就判错了。</p>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>三个顺序容器适配器：<code>stack</code>、<code>queue</code>和<code>priority_queue</code>。</p>
<p>一个适配器是一种机制，能使得某事物的行为看起来像另一种事物一样。</p>
<ul>
<li>例如，<code>stack</code>适配器接受一个顺序容器（<code>array</code>和<code>forward_list</code>除外），并使其操作起来像一个<code>stack</code>一样。</li>
</ul>
<p><strong>所有的适配器都要求容器具有添加、删除及方便访问尾元素的能力。</strong></p>
<p><img src="https://s2.loli.net/2023/06/22/I7gAqmxcMH9tLp2.png" alt="17-50.png" title="所有容器适配器都支持的操作和类型"></p>
<p>定义一个适配器。该部分内容较晦涩且实际用途不明（至少在我看来是绕了一个大圈实现了某种功能？），具体参阅第五版《C++ primer 中文版》第 329 页。</p>
<p>默认情况下，<code>stack</code>和<code>queue</code>是基于<code>deque</code>实现的，<code>priority_queue</code>是在<code>vector</code>之上实现的。我们可以创建适配器时，通过第二个参数来指定容器类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; intStack;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2023/06/22/Bc2CWHSGt6yMZum.png" alt="17-51.png" title="栈的操作"></p>
<p><img src="https://s2.loli.net/2023/06/22/O5gUBywDh79f6Wo.png" alt="17-52.png" title="queue 和 priority_queue"></p>
<p>注意：上图中，<code>q.pop()</code>注释写错了。应该为：“删除首元素 … 不返回此元素”。</p>
<h2 id="泛型算法概述"><a href="#泛型算法概述" class="headerlink" title="泛型算法概述"></a>泛型算法概述</h2><p>顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素、访问首尾元素、确定容器是否为空以及获得指向首元素或尾元素之后位置的迭代器。</p>
<p>我们可以想象用户可能还希望做其他很多有用的操作：查找特定元素、替换或删除一个特定值、重排元素顺序等。</p>
<p>标准库并未给每个容器都定义成员函数来实现这些操作，而是定义了一组<strong>泛型算法（generic algorithm）</strong>：称它们为“算法”，是因为它们实现了一些经典算法的公共接口，如排序和搜索；称它们是“泛型的”，是因为它们可以用于不同类型的元素和多种容器类型（不仅包括标准库类型，如 vector 或 list，还包括内置的数组类型），以及我们将看到的，还能用于其他类型的序列。</p>
<p>大多数算法都定义在头文件<code>algorithm</code>中。标准库还在头文件<code>numeric</code>中定义了一组数值泛型算法。</p>
<p>一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。</p>
<p>例如，我们有一个 int 的 vector ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">find</span>(vec.<span class="built_in">cbegin</span>(), vec.<span class="built_in">cend</span>(), val);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The value&quot;</span> &lt;&lt; val</span><br><span class="line">     &lt;&lt; (result == vec.<span class="built_in">cend</span>() ? <span class="string">&quot; is not present&quot;</span> : <span class="string">&quot; is present&quot;</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>例如，一个 string 的 list ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string val = <span class="string">&quot;a value&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">find</span>(lst.<span class="built_in">cbegin</span>(), lst.<span class="built_in">cend</span>(), val);</span><br></pre></td></tr></table></figure>
<p>类似的，由于指针就像内置数组上的迭代器一样，我们可以用 find 在数组中查找值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">27</span>, <span class="number">210</span>, <span class="number">12</span>, <span class="number">47</span>, <span class="number">109</span>, <span class="number">83</span>&#125;;</span><br><span class="line"><span class="type">int</span> val = <span class="number">83</span>;</span><br><span class="line"><span class="type">int</span>* result = <span class="built_in">find</span>(<span class="built_in">begin</span>(ia), <span class="built_in">end</span>(ia), val);</span><br></pre></td></tr></table></figure>
<p>上例中使用了标准库的<code>begin</code>和<code>end</code>函数，来获得指向 ia 中首元素和尾元素之后位置的指针，并传递给 find .</p>
<p>还可以在序列的子范围中查找。例如，在<code>ia[1]</code>、<code>ia[2]</code>、<code>ia[3]</code>中查找给定元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = <span class="built_in">find</span>(ia+<span class="number">1</span>, ia+<span class="number">4</span>, val);</span><br></pre></td></tr></table></figure>
<p><img src="https://bu.dusays.com/2023/06/26/64999b2e06053.png" alt="17-53.png"></p>
<p><strong>迭代器令算法不依赖于容器，但算法依赖于元素类型的操作。</strong></p>
<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p><img src="https://bu.dusays.com/2024/01/01/65929de7312da.png" alt="17-53dot5.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1z64y1U7hs?p=52">https://www.bilibili.com/video/BV1z64y1U7hs?p=52</a></p>
<h2 id="OOP-概述"><a href="#OOP-概述" class="headerlink" title="OOP 概述"></a>OOP 概述</h2><p>面向对象程序设计（object-oriented programming）的核心思想：</p>
<ul>
<li>数据抽象：接口与实现分离</li>
<li>继承：定义相似的类，并对其相似关系建模</li>
<li>动态绑定：在一定程度上忽略相似类的区别，以统一的方式使用它们</li>
</ul>
<p>通过继承（inheritance），联系在一起的类构成一种层次关系</p>
<ul>
<li>基类（base class）：定义共同拥有的成员</li>
<li>派生类（derived class）：定义特有的成员</li>
<li>虚函数（virtual function）：基类希望派生类各自定义自己合适的版本</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类必须通过使用类派生列表明确指出基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//因为 Bulk_quote 在它的类派生列表中使用了 public 关键字，因此</span></span><br><span class="line"><span class="comment">//我们完全可以把 Bulk_quote 对象当成 Quote 对象来使用。</span></span><br></pre></td></tr></table></figure>
<p>如果基类把一个函数声明成虚函数，则该函数在派生类中<strong>隐式地</strong>也是虚函数。</p>
<p>动态绑定（dynamic binding），我们能用同一段代码分别处理派生类和基类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">print_total</span><span class="params">(ostream&amp; os, <span class="type">const</span> Quote&amp; item, <span class="type">size_t</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//根据传入item形参的对象类型调用 Quote::net_prize 或 Bulk_quote::net_price</span></span><br><span class="line">    <span class="type">double</span> ret = item.<span class="built_in">net_price</span>(n);</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;ISBN: &quot;</span> &lt;&lt; item.<span class="built_in">isbn</span>()</span><br><span class="line">       &lt;&lt; <span class="string">&quot;#sold: &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;total due: &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//basic的类型是Quote, bulk的类型是Bulk_quote</span></span><br><span class="line"><span class="built_in">print_total</span>(cout, basic, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">print_total</span>(cout, bulk, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>使用基类的引用（或指针）调用一个虚函数时，将发生动态绑定（也叫运行时绑定：run-time binding）。</p>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><p><code>protected</code>访问运算符：基类希望它的派生类有权访问该成员，同时禁止其他用户访问。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Quote</span>(<span class="type">const</span> std::string&amp; book, <span class="type">double</span> sales_price):</span><br><span class="line">        <span class="built_in">bookNo</span>(book), <span class="built_in">price</span>(sales_price)&#123;&#125;</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span> n)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n*price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Quote</span>() = <span class="keyword">default</span>; <span class="comment">//对析构函数进行动态绑定</span></span><br><span class="line">    <span class="comment">//基类通常都应该定义一个虚析构函数，即使</span></span><br><span class="line">    <span class="comment">//该函数不执行任何实际操作也是如此。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string bookNo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">//派生类需要访问的基类（受保护的）成员</span></span><br><span class="line">    <span class="type">double</span> price = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Quote&#123; <span class="comment">//Bulk_quote 继承自 Quote</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string&amp;, <span class="type">double</span>, std::<span class="type">size_t</span>, <span class="type">double</span>);</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> min_qty = <span class="number">0</span>; <span class="comment">//适用折扣政策的最低购买量</span></span><br><span class="line">    <span class="type">double</span> discout = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//派生类经常（但不总是）覆盖它继承的虚函数</span></span><br></pre></td></tr></table></figure>
<p><code>protected</code>访问说明符的作用是控制派生类从基类继承来的成员是否对派生类的用户可见。</p>
<p>如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分。同时，在需要基类的引用或指针的地方，都可以使用派生类的对象。</p>
<p><img src="https://bu.dusays.com/2023/07/31/64c7273f1719d.png" alt="17-54.png" title="17-54.png “小队长大队长”"></p>
<p>派生类必须使用基类的构造函数来初始化继承来的成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string&amp; book, <span class="type">double</span> p, std::<span class="type">size_t</span> qty, <span class="type">double</span> disc):</span><br><span class="line">           <span class="built_in">Quote</span>(book, p), <span class="built_in">min_qty</span>(qty), <span class="built_in">discount</span>(disc)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>重写<code>net_price()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Bulk_quote::net_price</span><span class="params">(<span class="type">size_t</span> cnt)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;=min_qty)</span><br><span class="line">        <span class="keyword">return</span> cnt*(<span class="number">1</span>-discount)*price;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> cnt*price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承与静态成员：</p>
<p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">statmem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Derived&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Derived::f</span><span class="params">(<span class="type">const</span> Derived&amp; derived_obj)</span></span>&#123;</span><br><span class="line">    Base::<span class="built_in">statmem</span>();             <span class="comment">//ok</span></span><br><span class="line">    Derived::<span class="built_in">statmem</span>();          <span class="comment">//ok</span></span><br><span class="line">    derived_obj.<span class="built_in">statmem</span>();       <span class="comment">//ok</span></span><br><span class="line">    <span class="built_in">statmem</span>();  <span class="comment">//通过this对象访问，ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>派生类的声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Quote;  <span class="comment">//错误！</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span>;                 <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<p>如果要将某个类用作基类，则该类必须已经定义。</p>
<p>一个类是基类，同时也可以是一个派生类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span> : <span class="keyword">public</span> Base&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span> : <span class="keyword">public</span> D1&#123;<span class="comment">/*...*/</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>防止继承发生：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoDerived</span> <span class="keyword">final</span>&#123;<span class="comment">/*...*/</span>&#125;; <span class="comment">//不能作为基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Last</span> <span class="keyword">final</span> : Base&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bad</span> : NoDerived&#123;<span class="comment">/*...*/</span>&#125;;  <span class="comment">//错误！</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bad2</span> : Last&#123;<span class="comment">/*...*/</span>&#125;;      <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>
<p>使用基类的引用（或指针）时，实际上编译器并不清楚所绑定对象的真实类型。</p>
<ul>
<li>静态类型（static type）：编译时已知</li>
<li>动态类型（dynamic type）：运行时才可知</li>
</ul>
<p>不存在从基类向派生类的隐式类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Quote base;</span><br><span class="line">Bulk_quote* bulkP = &amp;base;  <span class="comment">//错误</span></span><br><span class="line">Bulk_quote&amp; bulkRef = base; <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote* itemP = &amp;bulk;  <span class="comment">//正确</span></span><br><span class="line">Bulk_quote* bulkP = itemP;  <span class="comment">/*错误：编译器只能通过检验静态类型来推断</span></span><br><span class="line"><span class="comment">               但这里可以通过 dynamic_cast 或 static_cast 进行转换*/</span></span><br></pre></td></tr></table></figure>
<p>在对象间不存在类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;   <span class="comment">//派生类对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类特有的部分会被切掉（sliced down）：</span></span><br><span class="line"><span class="function">Quote <span class="title">item</span><span class="params">(bulk)</span></span>;  <span class="comment">//使用 Quote::Quote(const Quote&amp;) 构造函数</span></span><br><span class="line">item = bulk;       <span class="comment">//使用 Quote::operator = (const Quote&amp;)</span></span><br></pre></td></tr></table></figure>
<p>【练习15.10】 回忆在 8.1 节中的讨论，解释第 284 页中将<code>ifstream</code>传递给<code>Sales_data</code>的<code>read</code>函数的程序是如何工作的。</p>
<p>【答】 在要求使用基类型对象的地方，可以使用派生类型的对象来代替，是静态类型和动态类型不同的典型例子。</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>对虚函数的调用可能在运行时才被解析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Quote <span class="title">base</span><span class="params">(<span class="string">&quot;0-201-1&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_total</span>(cout, base, <span class="number">10</span>);</span><br><span class="line"><span class="function">Bulk_quote <span class="title">derived</span><span class="params">(<span class="string">&quot;0-201-1&quot;</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">.19</span>)</span></span>;</span><br><span class="line"><span class="built_in">print_total</span>(cout, derived, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//--------- 对 比 ------------</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 动态绑定只有在通过指针或引用调用虚函数时才会发生</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">base = derived; <span class="comment">//把 derived 的 Quote 部分拷贝给 base</span></span><br><span class="line">base.<span class="built_in">net_price</span>(<span class="number">20</span>);  <span class="comment">//调用 Quote::net_price()</span></span><br></pre></td></tr></table></figure>
<p>基类中的虚函数在派生类中隐式地也是一个虚函数。该函数在基类中的形参必须与派生类中的形参严格匹配。</p>
<p><code>final</code>和<code>override</code>说明符：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span> : B&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;   <span class="comment">//ok</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">override</span></span>;         <span class="comment">//错误！</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;            <span class="comment">//错误！</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">override</span></span>;            <span class="comment">//错误！</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span> : B&#123;</span><br><span class="line">    <span class="comment">//从 B 继承 f2() 和 f3() ，覆盖 f1(int)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D3</span> : D2&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;  <span class="comment">//ok</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>;  <span class="comment">//错误！在 D2 中已经声明为 final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>如果虚函数使用默认实参，基类和派生类中定义的默认实参最好一致。</strong></p>
<p>回避虚函数的机制：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//强制调用基类中定义的函数版本而不管 baseP 的动态类型到底是什么</span></span><br><span class="line"><span class="type">double</span> undiscounted = baseP-&gt;Quote::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br><span class="line"><span class="comment">//该调用将在编译时完成解析</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>什么时候我们需要回避虚函数的默认机制呢？通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时。在此情况下，基类的版本通常完成继承层次中所有类型都要做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切相关的操作。<br>如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。</p>
</blockquote>
<p>【练习15.11】 为你的<code>Quote</code>类体系添加一个名为<code>debug</code>的虚函数，令其分别显示每个类的数据成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虚函数的构造练习</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bookNo=&quot;</span> &lt;&lt; bookNo &lt;&lt; <span class="string">&quot; price=&quot;</span> &lt;&lt; price &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123;  <span class="comment">// void debug() override&#123;&#125; ？</span></span><br><span class="line">        Quote::<span class="built_in">debug</span>(); <span class="comment">//bookNo 变量为 private, 所以不能直接访问 bookNo</span></span><br><span class="line">                        <span class="comment">//只能调用基类的 debug() 函数来显示</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;min_qty=&quot;</span> &lt;&lt; min_qty &lt;&lt; <span class="string">&quot; discount=&quot;</span> &lt;&lt; discount &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>需求：现在我们需要支持多种不同的折扣策略。共同点是每个折扣策略都需要一个购买量值和折扣值。</p>
<p>分析：我们可以定义一个<code>Disc_quote</code>类来支持不同的折扣策略，其中<code>Disc_quote</code>负责保存购买量值和折扣值。但是，<code>Disc_quote</code>类中的<code>net_price()</code>函数是没有实际含义的，为了防止用户编写出无意义的代码（具体查阅第五版《C++ primer（中文版）》第 540 页），我们必须重新考虑。<strong>我们根本就不希望用户创建<code>Disc_quote</code>对象，<code>Disc_quote</code>类表示的是一本打折书籍的通用概念，而非某种具体的折扣策略。</strong></p>
<p>做法：将<code>net_price()</code>定义为<strong>纯虚（pure virtual）</strong>函数。一个纯虚函数无须定义，在声明语句的分号之前书写<code>=0</code>就可以将一个虚函数说明为纯虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于保存折扣值和购买量的类，派生类使用这些数据可以实现不同的折扣策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Disc_quote</span> : <span class="keyword">public</span> Quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Disc_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Disc_quote</span>(<span class="type">const</span> std::string&amp; book, <span class="type">double</span> price,</span><br><span class="line">               std::<span class="type">size_t</span> qty, <span class="type">double</span> disc):</span><br><span class="line">               <span class="built_in">Quote</span>(book, price), <span class="built_in">quantity</span>(qty), <span class="built_in">discount</span>(disc)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::<span class="type">size_t</span> quantity = <span class="number">0</span>; <span class="comment">//折扣适用的购买量</span></span><br><span class="line">    <span class="type">double</span> discount = <span class="number">0.0</span>;    <span class="comment">//表示折扣的小数值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>可以为纯虚函数提供定义，但必须定义在类的外部。</strong></p>
<p>含有（或未经覆盖直接继承）纯虚函数的类是抽象基类。不能创建抽象基类的对象。</p>
<p>派生类构造函数只初始化它的直接基类（而不是最顶层的那个）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Disc_quote&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bulk_quote</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string&amp; book, <span class="type">double</span> price,</span><br><span class="line">               std::<span class="type">size_t</span> qty, <span class="type">double</span> disc):</span><br><span class="line">               <span class="built_in">Disc_quote</span>(book, price, qty, disc)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p><code>protected</code>说明符：</p>
<ul>
<li>和私有成员类似，受保护的成员对<strong>类的用户</strong>不可访问</li>
<li>和公有成员类似，受保护的成员对<strong>派生类的成员和友元</strong>可访问</li>
<li>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。<strong>派生类对于一个基类对象中的受保护成员没有任何访问特权。</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sneaky</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp;)</span></span>;  <span class="comment">//能访问 Sneaky::prot_mem</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clobber</span><span class="params">(Base&amp;)</span></span>;    <span class="comment">//不能访问 Base::prot_mem</span></span><br><span class="line">    <span class="type">int</span> j;                         <span class="comment">// j 默认是 private</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Sneaky&amp; s)</span></span>&#123;s.j = s.prot_mem = <span class="number">0</span>;&#125;  <span class="comment">//正确</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clobber</span><span class="params">(Base&amp; b)</span></span>&#123;b.prot_mem = <span class="number">0</span>;&#125;          <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>
<p>某个类对其继承来的成员的访问权限受到两个因素的影响：</p>
<ul>
<li>在基类中该成员的访问说明符</li>
<li>在派生类的派生列表中的访问说明符</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> prot_mem;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> priv_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pub_Derv</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="comment">//这个类里有两个成员：pub_mem()函数，public的；prot_mem数据成员，protected的</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> prot_mem;&#125;   <span class="comment">//正确。派生类能访问 protected 成员</span></span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">g</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> priv_mem;&#125;  <span class="comment">//错误！private 成员对于派生类不可访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Priv_Derv</span> : <span class="keyword">private</span> Base&#123;</span><br><span class="line">    <span class="comment">//这个类里有两个成员：pub_mem()函数、prot_mem数据成员。这两个权限都是private</span></span><br><span class="line">    <span class="comment">// private 不影响派生类的访问权限，只是影响对象的访问权限</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> prot_mem;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Pub_Derv d1;</span><br><span class="line">Priv_Derv d2;</span><br><span class="line">d1.<span class="built_in">pub_mem</span>(); <span class="comment">//正确</span></span><br><span class="line">d2.<span class="built_in">pub_mem</span>(); <span class="comment">//错误！pub_mem()在派生类Priv_Derv中是private的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//派生访问说明符还可以控制继承自派生类的新类的访问权限</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived_from_Public</span> : <span class="keyword">public</span> Pub_Derv&#123;</span><br><span class="line">    <span class="comment">//两个成员：一个public，一个protected</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_base</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> prot_mem;&#125; <span class="comment">//正确</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived_from_Private</span> : <span class="keyword">public</span> Priv_Derv&#123;</span><br><span class="line">    <span class="comment">//一个都没有了</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">use_base</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> prot_mem;&#125; <span class="comment">//错误！</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>严格来说，<code>private</code>成员可以继承，但只能通过内存地址等非常规方式进行访问。</strong> 下面举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://blog.csdn.net/k346k346/article/details/49652209</span></span><br><span class="line"><span class="comment">/*如果基类中并没有提供访问私有成员的公有函数，那么其私有成员是否</span></span><br><span class="line"><span class="comment">“存在”呢？还会不会被继承呢？其实，这些私有成员的确是存在的，而且</span></span><br><span class="line"><span class="comment">会被继承，只不过程序员无法通过正常的渠道访问到它们。考察如下程序，</span></span><br><span class="line"><span class="comment">通过一种特殊的方式访问了类的私有成员。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">privateFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;this is a private function of base class&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>()&#123;i=<span class="number">5</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">printBaseI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span>* p=<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="keyword">this</span>);<span class="comment">//获取当前对象的首地址</span></span><br><span class="line">		cout&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">usePrivateFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">void</span> (*func)()=<span class="literal">NULL</span>;</span><br><span class="line">		_asm</span><br><span class="line">		&#123;</span><br><span class="line">			mov eax,A::privateFunc;</span><br><span class="line">			mov func,eax;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">func</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	B b;</span><br><span class="line">	b.<span class="built_in">printBaseI</span>();</span><br><span class="line">	b.<span class="built_in">usePrivateFunction</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*=========== 程序输出结果 ==============//</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">this is a private function of base class</span></span><br><span class="line"><span class="comment">//======================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-------------------------- 解释 -----------------------------//</span></span><br><span class="line"><span class="comment">（1）虽然类 A 没有提供访问私有成员变量 i 的公有方法，但是</span></span><br><span class="line"><span class="comment">     在类 A（以及类 A 的派生类）对象中，都包含变量 i。</span></span><br><span class="line"><span class="comment">（2）虽然类 A 并没有提供访问私有成员函数 privateFunc() </span></span><br><span class="line"><span class="comment">     的公有函数，但是在程序代码区依然存有函数 privateFunc() </span></span><br><span class="line"><span class="comment">     的代码，通过内联汇编获取该函数的入口地址，仍然可以顺利调用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">综上所述，类的私有成员一定存在，也一定被继承到派生类中，从大小也可</span></span><br><span class="line"><span class="comment">以看出派生类包含了基类的私有成员，读者可自行考证。只不过受到 C++ </span></span><br><span class="line"><span class="comment">语法的限制，在派生类中访问基类的私有成员只能通过间接的方式进行。</span></span><br><span class="line"><span class="comment">————————————————</span></span><br><span class="line"><span class="comment">版权声明：本文为CSDN博主「恋喵大鲤鱼」的原创文章，遵循CC 4.0 BY-SA</span></span><br><span class="line"><span class="comment">         版权协议，转载请附上原文出处链接及本声明。</span></span><br><span class="line"><span class="comment">//-------------------------------------------------------------*/</span></span><br></pre></td></tr></table></figure>
<p>另外补充：书中的某些表述比较模糊，下面给出一个例子进一步说明某个情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有在派生类中才可以通过派生类对象访问基类的protected成员。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Derived d)</span></span>&#123;</span><br><span class="line">		d.i = <span class="number">3</span>;	<span class="comment">//只有在派生类中才可以通过派生类对象访问基类的protected成员。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Derived derived;</span><br><span class="line"><span class="comment">//	derived.i = 3;	//只有在派生类中才可以通过派生类对象访问基类的protected成员。</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>友元关系不能继承：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="comment">//其他成员与之前版本一致</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal</span>;  <span class="comment">// Pal 在访问 Base 的派生类时不具有特殊性</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pal</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(Base b)</span> </span>&#123;<span class="keyword">return</span> b.prot_mem;&#125;     <span class="comment">//正确</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f2</span><span class="params">(Sneaky s)</span> </span>&#123;<span class="keyword">return</span> s.j;&#125;         <span class="comment">//错误！</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f3</span><span class="params">(Sneaky s)</span> </span>&#123;<span class="keyword">return</span> s.prot_mem;&#125;  <span class="comment">//正确，虽然看上去有点奇怪</span></span><br><span class="line"><span class="comment">//Pal能够访问Base的成员，这种访问包括了Base对象内嵌在其派生类对象中的情况</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span> : <span class="keyword">public</span> Pal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mem</span><span class="params">(Base b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.prot_mem; <span class="comment">//错误！友元关系不能继承</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过使用<code>using</code>改变个别成员的可访问性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> n;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::<span class="type">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类只能为那些它可以访问的名字提供 using 声明</span></span><br></pre></td></tr></table></figure>
<p>默认的继承保护级别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;<span class="comment">/*===*/</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span> : Base &#123;<span class="comment">/*---*/</span>&#125;;  <span class="comment">//默认 public 继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span> : Base &#123;<span class="comment">/*---*/</span>&#125;;   <span class="comment">//默认 private 继承</span></span><br></pre></td></tr></table></figure>
<h2 id="未完待续-1"><a href="#未完待续-1" class="headerlink" title="未完待续"></a>未完待续</h2><p>两个未完待续之间的内容并未学习。</p>
<p><img src="https://bu.dusays.com/2024/01/01/65929de79bf47.png" alt="17-55.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1z64y1U7hs?p=79">https://www.bilibili.com/video/BV1z64y1U7hs?p=79</a></p>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
                <div class="icon arrow-left"></div>
                <div class="post-link">
                    <a href="/2023/01/31/230131_P6175/">Prev</a>
                </div>
            
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2022/11/07/221107_weigjj/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

     

     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
                ©2022 - 2024 By rainman | 
            
            
                Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
                
        </div>
    </div>
</div>

    </div>

    
    

  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="//cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
